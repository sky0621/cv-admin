// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/sky0621/cv-admin/src/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/sky0621/cv-admin/src/ent/careerskill"
	"github.com/sky0621/cv-admin/src/ent/careerskillgroup"
	"github.com/sky0621/cv-admin/src/ent/careertask"
	"github.com/sky0621/cv-admin/src/ent/careertaskdescription"
	"github.com/sky0621/cv-admin/src/ent/skill"
	"github.com/sky0621/cv-admin/src/ent/skilltag"
	"github.com/sky0621/cv-admin/src/ent/user"
	"github.com/sky0621/cv-admin/src/ent/useractivity"
	"github.com/sky0621/cv-admin/src/ent/usercareer"
	"github.com/sky0621/cv-admin/src/ent/usercareerdescription"
	"github.com/sky0621/cv-admin/src/ent/usercareergroup"
	"github.com/sky0621/cv-admin/src/ent/usernote"
	"github.com/sky0621/cv-admin/src/ent/usernoteitem"
	"github.com/sky0621/cv-admin/src/ent/userqualification"
	"github.com/sky0621/cv-admin/src/ent/usersolution"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// CareerSkill is the client for interacting with the CareerSkill builders.
	CareerSkill *CareerSkillClient
	// CareerSkillGroup is the client for interacting with the CareerSkillGroup builders.
	CareerSkillGroup *CareerSkillGroupClient
	// CareerTask is the client for interacting with the CareerTask builders.
	CareerTask *CareerTaskClient
	// CareerTaskDescription is the client for interacting with the CareerTaskDescription builders.
	CareerTaskDescription *CareerTaskDescriptionClient
	// Skill is the client for interacting with the Skill builders.
	Skill *SkillClient
	// SkillTag is the client for interacting with the SkillTag builders.
	SkillTag *SkillTagClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserActivity is the client for interacting with the UserActivity builders.
	UserActivity *UserActivityClient
	// UserCareer is the client for interacting with the UserCareer builders.
	UserCareer *UserCareerClient
	// UserCareerDescription is the client for interacting with the UserCareerDescription builders.
	UserCareerDescription *UserCareerDescriptionClient
	// UserCareerGroup is the client for interacting with the UserCareerGroup builders.
	UserCareerGroup *UserCareerGroupClient
	// UserNote is the client for interacting with the UserNote builders.
	UserNote *UserNoteClient
	// UserNoteItem is the client for interacting with the UserNoteItem builders.
	UserNoteItem *UserNoteItemClient
	// UserQualification is the client for interacting with the UserQualification builders.
	UserQualification *UserQualificationClient
	// UserSolution is the client for interacting with the UserSolution builders.
	UserSolution *UserSolutionClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.CareerSkill = NewCareerSkillClient(c.config)
	c.CareerSkillGroup = NewCareerSkillGroupClient(c.config)
	c.CareerTask = NewCareerTaskClient(c.config)
	c.CareerTaskDescription = NewCareerTaskDescriptionClient(c.config)
	c.Skill = NewSkillClient(c.config)
	c.SkillTag = NewSkillTagClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserActivity = NewUserActivityClient(c.config)
	c.UserCareer = NewUserCareerClient(c.config)
	c.UserCareerDescription = NewUserCareerDescriptionClient(c.config)
	c.UserCareerGroup = NewUserCareerGroupClient(c.config)
	c.UserNote = NewUserNoteClient(c.config)
	c.UserNoteItem = NewUserNoteItemClient(c.config)
	c.UserQualification = NewUserQualificationClient(c.config)
	c.UserSolution = NewUserSolutionClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		CareerSkill:           NewCareerSkillClient(cfg),
		CareerSkillGroup:      NewCareerSkillGroupClient(cfg),
		CareerTask:            NewCareerTaskClient(cfg),
		CareerTaskDescription: NewCareerTaskDescriptionClient(cfg),
		Skill:                 NewSkillClient(cfg),
		SkillTag:              NewSkillTagClient(cfg),
		User:                  NewUserClient(cfg),
		UserActivity:          NewUserActivityClient(cfg),
		UserCareer:            NewUserCareerClient(cfg),
		UserCareerDescription: NewUserCareerDescriptionClient(cfg),
		UserCareerGroup:       NewUserCareerGroupClient(cfg),
		UserNote:              NewUserNoteClient(cfg),
		UserNoteItem:          NewUserNoteItemClient(cfg),
		UserQualification:     NewUserQualificationClient(cfg),
		UserSolution:          NewUserSolutionClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		CareerSkill:           NewCareerSkillClient(cfg),
		CareerSkillGroup:      NewCareerSkillGroupClient(cfg),
		CareerTask:            NewCareerTaskClient(cfg),
		CareerTaskDescription: NewCareerTaskDescriptionClient(cfg),
		Skill:                 NewSkillClient(cfg),
		SkillTag:              NewSkillTagClient(cfg),
		User:                  NewUserClient(cfg),
		UserActivity:          NewUserActivityClient(cfg),
		UserCareer:            NewUserCareerClient(cfg),
		UserCareerDescription: NewUserCareerDescriptionClient(cfg),
		UserCareerGroup:       NewUserCareerGroupClient(cfg),
		UserNote:              NewUserNoteClient(cfg),
		UserNoteItem:          NewUserNoteItemClient(cfg),
		UserQualification:     NewUserQualificationClient(cfg),
		UserSolution:          NewUserSolutionClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		CareerSkill.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.CareerSkill, c.CareerSkillGroup, c.CareerTask, c.CareerTaskDescription,
		c.Skill, c.SkillTag, c.User, c.UserActivity, c.UserCareer,
		c.UserCareerDescription, c.UserCareerGroup, c.UserNote, c.UserNoteItem,
		c.UserQualification, c.UserSolution,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.CareerSkill, c.CareerSkillGroup, c.CareerTask, c.CareerTaskDescription,
		c.Skill, c.SkillTag, c.User, c.UserActivity, c.UserCareer,
		c.UserCareerDescription, c.UserCareerGroup, c.UserNote, c.UserNoteItem,
		c.UserQualification, c.UserSolution,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *CareerSkillMutation:
		return c.CareerSkill.mutate(ctx, m)
	case *CareerSkillGroupMutation:
		return c.CareerSkillGroup.mutate(ctx, m)
	case *CareerTaskMutation:
		return c.CareerTask.mutate(ctx, m)
	case *CareerTaskDescriptionMutation:
		return c.CareerTaskDescription.mutate(ctx, m)
	case *SkillMutation:
		return c.Skill.mutate(ctx, m)
	case *SkillTagMutation:
		return c.SkillTag.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserActivityMutation:
		return c.UserActivity.mutate(ctx, m)
	case *UserCareerMutation:
		return c.UserCareer.mutate(ctx, m)
	case *UserCareerDescriptionMutation:
		return c.UserCareerDescription.mutate(ctx, m)
	case *UserCareerGroupMutation:
		return c.UserCareerGroup.mutate(ctx, m)
	case *UserNoteMutation:
		return c.UserNote.mutate(ctx, m)
	case *UserNoteItemMutation:
		return c.UserNoteItem.mutate(ctx, m)
	case *UserQualificationMutation:
		return c.UserQualification.mutate(ctx, m)
	case *UserSolutionMutation:
		return c.UserSolution.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// CareerSkillClient is a client for the CareerSkill schema.
type CareerSkillClient struct {
	config
}

// NewCareerSkillClient returns a client for the CareerSkill from the given config.
func NewCareerSkillClient(c config) *CareerSkillClient {
	return &CareerSkillClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `careerskill.Hooks(f(g(h())))`.
func (c *CareerSkillClient) Use(hooks ...Hook) {
	c.hooks.CareerSkill = append(c.hooks.CareerSkill, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `careerskill.Intercept(f(g(h())))`.
func (c *CareerSkillClient) Intercept(interceptors ...Interceptor) {
	c.inters.CareerSkill = append(c.inters.CareerSkill, interceptors...)
}

// Create returns a builder for creating a CareerSkill entity.
func (c *CareerSkillClient) Create() *CareerSkillCreate {
	mutation := newCareerSkillMutation(c.config, OpCreate)
	return &CareerSkillCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CareerSkill entities.
func (c *CareerSkillClient) CreateBulk(builders ...*CareerSkillCreate) *CareerSkillCreateBulk {
	return &CareerSkillCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CareerSkillClient) MapCreateBulk(slice any, setFunc func(*CareerSkillCreate, int)) *CareerSkillCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CareerSkillCreateBulk{err: fmt.Errorf("calling to CareerSkillClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CareerSkillCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CareerSkillCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CareerSkill.
func (c *CareerSkillClient) Update() *CareerSkillUpdate {
	mutation := newCareerSkillMutation(c.config, OpUpdate)
	return &CareerSkillUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CareerSkillClient) UpdateOne(cs *CareerSkill) *CareerSkillUpdateOne {
	mutation := newCareerSkillMutation(c.config, OpUpdateOne, withCareerSkill(cs))
	return &CareerSkillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CareerSkillClient) UpdateOneID(id int) *CareerSkillUpdateOne {
	mutation := newCareerSkillMutation(c.config, OpUpdateOne, withCareerSkillID(id))
	return &CareerSkillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CareerSkill.
func (c *CareerSkillClient) Delete() *CareerSkillDelete {
	mutation := newCareerSkillMutation(c.config, OpDelete)
	return &CareerSkillDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CareerSkillClient) DeleteOne(cs *CareerSkill) *CareerSkillDeleteOne {
	return c.DeleteOneID(cs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CareerSkillClient) DeleteOneID(id int) *CareerSkillDeleteOne {
	builder := c.Delete().Where(careerskill.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CareerSkillDeleteOne{builder}
}

// Query returns a query builder for CareerSkill.
func (c *CareerSkillClient) Query() *CareerSkillQuery {
	return &CareerSkillQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCareerSkill},
		inters: c.Interceptors(),
	}
}

// Get returns a CareerSkill entity by its id.
func (c *CareerSkillClient) Get(ctx context.Context, id int) (*CareerSkill, error) {
	return c.Query().Where(careerskill.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CareerSkillClient) GetX(ctx context.Context, id int) *CareerSkill {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCareerSkillGroup queries the careerSkillGroup edge of a CareerSkill.
func (c *CareerSkillClient) QueryCareerSkillGroup(cs *CareerSkill) *CareerSkillGroupQuery {
	query := (&CareerSkillGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(careerskill.Table, careerskill.FieldID, id),
			sqlgraph.To(careerskillgroup.Table, careerskillgroup.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, careerskill.CareerSkillGroupTable, careerskill.CareerSkillGroupColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySkill queries the skill edge of a CareerSkill.
func (c *CareerSkillClient) QuerySkill(cs *CareerSkill) *SkillQuery {
	query := (&SkillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(careerskill.Table, careerskill.FieldID, id),
			sqlgraph.To(skill.Table, skill.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, careerskill.SkillTable, careerskill.SkillColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CareerSkillClient) Hooks() []Hook {
	return c.hooks.CareerSkill
}

// Interceptors returns the client interceptors.
func (c *CareerSkillClient) Interceptors() []Interceptor {
	return c.inters.CareerSkill
}

func (c *CareerSkillClient) mutate(ctx context.Context, m *CareerSkillMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CareerSkillCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CareerSkillUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CareerSkillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CareerSkillDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CareerSkill mutation op: %q", m.Op())
	}
}

// CareerSkillGroupClient is a client for the CareerSkillGroup schema.
type CareerSkillGroupClient struct {
	config
}

// NewCareerSkillGroupClient returns a client for the CareerSkillGroup from the given config.
func NewCareerSkillGroupClient(c config) *CareerSkillGroupClient {
	return &CareerSkillGroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `careerskillgroup.Hooks(f(g(h())))`.
func (c *CareerSkillGroupClient) Use(hooks ...Hook) {
	c.hooks.CareerSkillGroup = append(c.hooks.CareerSkillGroup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `careerskillgroup.Intercept(f(g(h())))`.
func (c *CareerSkillGroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.CareerSkillGroup = append(c.inters.CareerSkillGroup, interceptors...)
}

// Create returns a builder for creating a CareerSkillGroup entity.
func (c *CareerSkillGroupClient) Create() *CareerSkillGroupCreate {
	mutation := newCareerSkillGroupMutation(c.config, OpCreate)
	return &CareerSkillGroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CareerSkillGroup entities.
func (c *CareerSkillGroupClient) CreateBulk(builders ...*CareerSkillGroupCreate) *CareerSkillGroupCreateBulk {
	return &CareerSkillGroupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CareerSkillGroupClient) MapCreateBulk(slice any, setFunc func(*CareerSkillGroupCreate, int)) *CareerSkillGroupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CareerSkillGroupCreateBulk{err: fmt.Errorf("calling to CareerSkillGroupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CareerSkillGroupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CareerSkillGroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CareerSkillGroup.
func (c *CareerSkillGroupClient) Update() *CareerSkillGroupUpdate {
	mutation := newCareerSkillGroupMutation(c.config, OpUpdate)
	return &CareerSkillGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CareerSkillGroupClient) UpdateOne(csg *CareerSkillGroup) *CareerSkillGroupUpdateOne {
	mutation := newCareerSkillGroupMutation(c.config, OpUpdateOne, withCareerSkillGroup(csg))
	return &CareerSkillGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CareerSkillGroupClient) UpdateOneID(id int) *CareerSkillGroupUpdateOne {
	mutation := newCareerSkillGroupMutation(c.config, OpUpdateOne, withCareerSkillGroupID(id))
	return &CareerSkillGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CareerSkillGroup.
func (c *CareerSkillGroupClient) Delete() *CareerSkillGroupDelete {
	mutation := newCareerSkillGroupMutation(c.config, OpDelete)
	return &CareerSkillGroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CareerSkillGroupClient) DeleteOne(csg *CareerSkillGroup) *CareerSkillGroupDeleteOne {
	return c.DeleteOneID(csg.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CareerSkillGroupClient) DeleteOneID(id int) *CareerSkillGroupDeleteOne {
	builder := c.Delete().Where(careerskillgroup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CareerSkillGroupDeleteOne{builder}
}

// Query returns a query builder for CareerSkillGroup.
func (c *CareerSkillGroupClient) Query() *CareerSkillGroupQuery {
	return &CareerSkillGroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCareerSkillGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a CareerSkillGroup entity by its id.
func (c *CareerSkillGroupClient) Get(ctx context.Context, id int) (*CareerSkillGroup, error) {
	return c.Query().Where(careerskillgroup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CareerSkillGroupClient) GetX(ctx context.Context, id int) *CareerSkillGroup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCareer queries the career edge of a CareerSkillGroup.
func (c *CareerSkillGroupClient) QueryCareer(csg *CareerSkillGroup) *UserCareerQuery {
	query := (&UserCareerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := csg.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(careerskillgroup.Table, careerskillgroup.FieldID, id),
			sqlgraph.To(usercareer.Table, usercareer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, careerskillgroup.CareerTable, careerskillgroup.CareerColumn),
		)
		fromV = sqlgraph.Neighbors(csg.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCareerSkills queries the careerSkills edge of a CareerSkillGroup.
func (c *CareerSkillGroupClient) QueryCareerSkills(csg *CareerSkillGroup) *CareerSkillQuery {
	query := (&CareerSkillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := csg.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(careerskillgroup.Table, careerskillgroup.FieldID, id),
			sqlgraph.To(careerskill.Table, careerskill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, careerskillgroup.CareerSkillsTable, careerskillgroup.CareerSkillsColumn),
		)
		fromV = sqlgraph.Neighbors(csg.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CareerSkillGroupClient) Hooks() []Hook {
	return c.hooks.CareerSkillGroup
}

// Interceptors returns the client interceptors.
func (c *CareerSkillGroupClient) Interceptors() []Interceptor {
	return c.inters.CareerSkillGroup
}

func (c *CareerSkillGroupClient) mutate(ctx context.Context, m *CareerSkillGroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CareerSkillGroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CareerSkillGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CareerSkillGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CareerSkillGroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CareerSkillGroup mutation op: %q", m.Op())
	}
}

// CareerTaskClient is a client for the CareerTask schema.
type CareerTaskClient struct {
	config
}

// NewCareerTaskClient returns a client for the CareerTask from the given config.
func NewCareerTaskClient(c config) *CareerTaskClient {
	return &CareerTaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `careertask.Hooks(f(g(h())))`.
func (c *CareerTaskClient) Use(hooks ...Hook) {
	c.hooks.CareerTask = append(c.hooks.CareerTask, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `careertask.Intercept(f(g(h())))`.
func (c *CareerTaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.CareerTask = append(c.inters.CareerTask, interceptors...)
}

// Create returns a builder for creating a CareerTask entity.
func (c *CareerTaskClient) Create() *CareerTaskCreate {
	mutation := newCareerTaskMutation(c.config, OpCreate)
	return &CareerTaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CareerTask entities.
func (c *CareerTaskClient) CreateBulk(builders ...*CareerTaskCreate) *CareerTaskCreateBulk {
	return &CareerTaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CareerTaskClient) MapCreateBulk(slice any, setFunc func(*CareerTaskCreate, int)) *CareerTaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CareerTaskCreateBulk{err: fmt.Errorf("calling to CareerTaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CareerTaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CareerTaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CareerTask.
func (c *CareerTaskClient) Update() *CareerTaskUpdate {
	mutation := newCareerTaskMutation(c.config, OpUpdate)
	return &CareerTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CareerTaskClient) UpdateOne(ct *CareerTask) *CareerTaskUpdateOne {
	mutation := newCareerTaskMutation(c.config, OpUpdateOne, withCareerTask(ct))
	return &CareerTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CareerTaskClient) UpdateOneID(id int) *CareerTaskUpdateOne {
	mutation := newCareerTaskMutation(c.config, OpUpdateOne, withCareerTaskID(id))
	return &CareerTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CareerTask.
func (c *CareerTaskClient) Delete() *CareerTaskDelete {
	mutation := newCareerTaskMutation(c.config, OpDelete)
	return &CareerTaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CareerTaskClient) DeleteOne(ct *CareerTask) *CareerTaskDeleteOne {
	return c.DeleteOneID(ct.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CareerTaskClient) DeleteOneID(id int) *CareerTaskDeleteOne {
	builder := c.Delete().Where(careertask.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CareerTaskDeleteOne{builder}
}

// Query returns a query builder for CareerTask.
func (c *CareerTaskClient) Query() *CareerTaskQuery {
	return &CareerTaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCareerTask},
		inters: c.Interceptors(),
	}
}

// Get returns a CareerTask entity by its id.
func (c *CareerTaskClient) Get(ctx context.Context, id int) (*CareerTask, error) {
	return c.Query().Where(careertask.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CareerTaskClient) GetX(ctx context.Context, id int) *CareerTask {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCareer queries the career edge of a CareerTask.
func (c *CareerTaskClient) QueryCareer(ct *CareerTask) *UserCareerQuery {
	query := (&UserCareerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ct.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(careertask.Table, careertask.FieldID, id),
			sqlgraph.To(usercareer.Table, usercareer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, careertask.CareerTable, careertask.CareerColumn),
		)
		fromV = sqlgraph.Neighbors(ct.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCareerTaskDescriptions queries the careerTaskDescriptions edge of a CareerTask.
func (c *CareerTaskClient) QueryCareerTaskDescriptions(ct *CareerTask) *CareerTaskDescriptionQuery {
	query := (&CareerTaskDescriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ct.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(careertask.Table, careertask.FieldID, id),
			sqlgraph.To(careertaskdescription.Table, careertaskdescription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, careertask.CareerTaskDescriptionsTable, careertask.CareerTaskDescriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(ct.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CareerTaskClient) Hooks() []Hook {
	return c.hooks.CareerTask
}

// Interceptors returns the client interceptors.
func (c *CareerTaskClient) Interceptors() []Interceptor {
	return c.inters.CareerTask
}

func (c *CareerTaskClient) mutate(ctx context.Context, m *CareerTaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CareerTaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CareerTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CareerTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CareerTaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CareerTask mutation op: %q", m.Op())
	}
}

// CareerTaskDescriptionClient is a client for the CareerTaskDescription schema.
type CareerTaskDescriptionClient struct {
	config
}

// NewCareerTaskDescriptionClient returns a client for the CareerTaskDescription from the given config.
func NewCareerTaskDescriptionClient(c config) *CareerTaskDescriptionClient {
	return &CareerTaskDescriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `careertaskdescription.Hooks(f(g(h())))`.
func (c *CareerTaskDescriptionClient) Use(hooks ...Hook) {
	c.hooks.CareerTaskDescription = append(c.hooks.CareerTaskDescription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `careertaskdescription.Intercept(f(g(h())))`.
func (c *CareerTaskDescriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.CareerTaskDescription = append(c.inters.CareerTaskDescription, interceptors...)
}

// Create returns a builder for creating a CareerTaskDescription entity.
func (c *CareerTaskDescriptionClient) Create() *CareerTaskDescriptionCreate {
	mutation := newCareerTaskDescriptionMutation(c.config, OpCreate)
	return &CareerTaskDescriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CareerTaskDescription entities.
func (c *CareerTaskDescriptionClient) CreateBulk(builders ...*CareerTaskDescriptionCreate) *CareerTaskDescriptionCreateBulk {
	return &CareerTaskDescriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CareerTaskDescriptionClient) MapCreateBulk(slice any, setFunc func(*CareerTaskDescriptionCreate, int)) *CareerTaskDescriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CareerTaskDescriptionCreateBulk{err: fmt.Errorf("calling to CareerTaskDescriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CareerTaskDescriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CareerTaskDescriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CareerTaskDescription.
func (c *CareerTaskDescriptionClient) Update() *CareerTaskDescriptionUpdate {
	mutation := newCareerTaskDescriptionMutation(c.config, OpUpdate)
	return &CareerTaskDescriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CareerTaskDescriptionClient) UpdateOne(ctd *CareerTaskDescription) *CareerTaskDescriptionUpdateOne {
	mutation := newCareerTaskDescriptionMutation(c.config, OpUpdateOne, withCareerTaskDescription(ctd))
	return &CareerTaskDescriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CareerTaskDescriptionClient) UpdateOneID(id int) *CareerTaskDescriptionUpdateOne {
	mutation := newCareerTaskDescriptionMutation(c.config, OpUpdateOne, withCareerTaskDescriptionID(id))
	return &CareerTaskDescriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CareerTaskDescription.
func (c *CareerTaskDescriptionClient) Delete() *CareerTaskDescriptionDelete {
	mutation := newCareerTaskDescriptionMutation(c.config, OpDelete)
	return &CareerTaskDescriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CareerTaskDescriptionClient) DeleteOne(ctd *CareerTaskDescription) *CareerTaskDescriptionDeleteOne {
	return c.DeleteOneID(ctd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CareerTaskDescriptionClient) DeleteOneID(id int) *CareerTaskDescriptionDeleteOne {
	builder := c.Delete().Where(careertaskdescription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CareerTaskDescriptionDeleteOne{builder}
}

// Query returns a query builder for CareerTaskDescription.
func (c *CareerTaskDescriptionClient) Query() *CareerTaskDescriptionQuery {
	return &CareerTaskDescriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCareerTaskDescription},
		inters: c.Interceptors(),
	}
}

// Get returns a CareerTaskDescription entity by its id.
func (c *CareerTaskDescriptionClient) Get(ctx context.Context, id int) (*CareerTaskDescription, error) {
	return c.Query().Where(careertaskdescription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CareerTaskDescriptionClient) GetX(ctx context.Context, id int) *CareerTaskDescription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCareerTask queries the careerTask edge of a CareerTaskDescription.
func (c *CareerTaskDescriptionClient) QueryCareerTask(ctd *CareerTaskDescription) *CareerTaskQuery {
	query := (&CareerTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ctd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(careertaskdescription.Table, careertaskdescription.FieldID, id),
			sqlgraph.To(careertask.Table, careertask.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, careertaskdescription.CareerTaskTable, careertaskdescription.CareerTaskColumn),
		)
		fromV = sqlgraph.Neighbors(ctd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CareerTaskDescriptionClient) Hooks() []Hook {
	return c.hooks.CareerTaskDescription
}

// Interceptors returns the client interceptors.
func (c *CareerTaskDescriptionClient) Interceptors() []Interceptor {
	return c.inters.CareerTaskDescription
}

func (c *CareerTaskDescriptionClient) mutate(ctx context.Context, m *CareerTaskDescriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CareerTaskDescriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CareerTaskDescriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CareerTaskDescriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CareerTaskDescriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CareerTaskDescription mutation op: %q", m.Op())
	}
}

// SkillClient is a client for the Skill schema.
type SkillClient struct {
	config
}

// NewSkillClient returns a client for the Skill from the given config.
func NewSkillClient(c config) *SkillClient {
	return &SkillClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `skill.Hooks(f(g(h())))`.
func (c *SkillClient) Use(hooks ...Hook) {
	c.hooks.Skill = append(c.hooks.Skill, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `skill.Intercept(f(g(h())))`.
func (c *SkillClient) Intercept(interceptors ...Interceptor) {
	c.inters.Skill = append(c.inters.Skill, interceptors...)
}

// Create returns a builder for creating a Skill entity.
func (c *SkillClient) Create() *SkillCreate {
	mutation := newSkillMutation(c.config, OpCreate)
	return &SkillCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Skill entities.
func (c *SkillClient) CreateBulk(builders ...*SkillCreate) *SkillCreateBulk {
	return &SkillCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SkillClient) MapCreateBulk(slice any, setFunc func(*SkillCreate, int)) *SkillCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SkillCreateBulk{err: fmt.Errorf("calling to SkillClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SkillCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SkillCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Skill.
func (c *SkillClient) Update() *SkillUpdate {
	mutation := newSkillMutation(c.config, OpUpdate)
	return &SkillUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SkillClient) UpdateOne(s *Skill) *SkillUpdateOne {
	mutation := newSkillMutation(c.config, OpUpdateOne, withSkill(s))
	return &SkillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SkillClient) UpdateOneID(id int) *SkillUpdateOne {
	mutation := newSkillMutation(c.config, OpUpdateOne, withSkillID(id))
	return &SkillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Skill.
func (c *SkillClient) Delete() *SkillDelete {
	mutation := newSkillMutation(c.config, OpDelete)
	return &SkillDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SkillClient) DeleteOne(s *Skill) *SkillDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SkillClient) DeleteOneID(id int) *SkillDeleteOne {
	builder := c.Delete().Where(skill.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SkillDeleteOne{builder}
}

// Query returns a query builder for Skill.
func (c *SkillClient) Query() *SkillQuery {
	return &SkillQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSkill},
		inters: c.Interceptors(),
	}
}

// Get returns a Skill entity by its id.
func (c *SkillClient) Get(ctx context.Context, id int) (*Skill, error) {
	return c.Query().Where(skill.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SkillClient) GetX(ctx context.Context, id int) *Skill {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySkillTag queries the skillTag edge of a Skill.
func (c *SkillClient) QuerySkillTag(s *Skill) *SkillTagQuery {
	query := (&SkillTagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(skill.Table, skill.FieldID, id),
			sqlgraph.To(skilltag.Table, skilltag.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, skill.SkillTagTable, skill.SkillTagColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCareerSkills queries the careerSkills edge of a Skill.
func (c *SkillClient) QueryCareerSkills(s *Skill) *CareerSkillQuery {
	query := (&CareerSkillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(skill.Table, skill.FieldID, id),
			sqlgraph.To(careerskill.Table, careerskill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, skill.CareerSkillsTable, skill.CareerSkillsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SkillClient) Hooks() []Hook {
	return c.hooks.Skill
}

// Interceptors returns the client interceptors.
func (c *SkillClient) Interceptors() []Interceptor {
	return c.inters.Skill
}

func (c *SkillClient) mutate(ctx context.Context, m *SkillMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SkillCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SkillUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SkillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SkillDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Skill mutation op: %q", m.Op())
	}
}

// SkillTagClient is a client for the SkillTag schema.
type SkillTagClient struct {
	config
}

// NewSkillTagClient returns a client for the SkillTag from the given config.
func NewSkillTagClient(c config) *SkillTagClient {
	return &SkillTagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `skilltag.Hooks(f(g(h())))`.
func (c *SkillTagClient) Use(hooks ...Hook) {
	c.hooks.SkillTag = append(c.hooks.SkillTag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `skilltag.Intercept(f(g(h())))`.
func (c *SkillTagClient) Intercept(interceptors ...Interceptor) {
	c.inters.SkillTag = append(c.inters.SkillTag, interceptors...)
}

// Create returns a builder for creating a SkillTag entity.
func (c *SkillTagClient) Create() *SkillTagCreate {
	mutation := newSkillTagMutation(c.config, OpCreate)
	return &SkillTagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SkillTag entities.
func (c *SkillTagClient) CreateBulk(builders ...*SkillTagCreate) *SkillTagCreateBulk {
	return &SkillTagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SkillTagClient) MapCreateBulk(slice any, setFunc func(*SkillTagCreate, int)) *SkillTagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SkillTagCreateBulk{err: fmt.Errorf("calling to SkillTagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SkillTagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SkillTagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SkillTag.
func (c *SkillTagClient) Update() *SkillTagUpdate {
	mutation := newSkillTagMutation(c.config, OpUpdate)
	return &SkillTagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SkillTagClient) UpdateOne(st *SkillTag) *SkillTagUpdateOne {
	mutation := newSkillTagMutation(c.config, OpUpdateOne, withSkillTag(st))
	return &SkillTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SkillTagClient) UpdateOneID(id int) *SkillTagUpdateOne {
	mutation := newSkillTagMutation(c.config, OpUpdateOne, withSkillTagID(id))
	return &SkillTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SkillTag.
func (c *SkillTagClient) Delete() *SkillTagDelete {
	mutation := newSkillTagMutation(c.config, OpDelete)
	return &SkillTagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SkillTagClient) DeleteOne(st *SkillTag) *SkillTagDeleteOne {
	return c.DeleteOneID(st.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SkillTagClient) DeleteOneID(id int) *SkillTagDeleteOne {
	builder := c.Delete().Where(skilltag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SkillTagDeleteOne{builder}
}

// Query returns a query builder for SkillTag.
func (c *SkillTagClient) Query() *SkillTagQuery {
	return &SkillTagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSkillTag},
		inters: c.Interceptors(),
	}
}

// Get returns a SkillTag entity by its id.
func (c *SkillTagClient) Get(ctx context.Context, id int) (*SkillTag, error) {
	return c.Query().Where(skilltag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SkillTagClient) GetX(ctx context.Context, id int) *SkillTag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySkills queries the skills edge of a SkillTag.
func (c *SkillTagClient) QuerySkills(st *SkillTag) *SkillQuery {
	query := (&SkillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(skilltag.Table, skilltag.FieldID, id),
			sqlgraph.To(skill.Table, skill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, skilltag.SkillsTable, skilltag.SkillsColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SkillTagClient) Hooks() []Hook {
	return c.hooks.SkillTag
}

// Interceptors returns the client interceptors.
func (c *SkillTagClient) Interceptors() []Interceptor {
	return c.inters.SkillTag
}

func (c *SkillTagClient) mutate(ctx context.Context, m *SkillTagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SkillTagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SkillTagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SkillTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SkillTagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SkillTag mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryActivities queries the activities edge of a User.
func (c *UserClient) QueryActivities(u *User) *UserActivityQuery {
	query := (&UserActivityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(useractivity.Table, useractivity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ActivitiesTable, user.ActivitiesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQualifications queries the qualifications edge of a User.
func (c *UserClient) QueryQualifications(u *User) *UserQualificationQuery {
	query := (&UserQualificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userqualification.Table, userqualification.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.QualificationsTable, user.QualificationsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCareerGroups queries the careerGroups edge of a User.
func (c *UserClient) QueryCareerGroups(u *User) *UserCareerGroupQuery {
	query := (&UserCareerGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usercareergroup.Table, usercareergroup.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CareerGroupsTable, user.CareerGroupsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotes queries the notes edge of a User.
func (c *UserClient) QueryNotes(u *User) *UserNoteQuery {
	query := (&UserNoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usernote.Table, usernote.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.NotesTable, user.NotesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySolutions queries the solutions edge of a User.
func (c *UserClient) QuerySolutions(u *User) *UserSolutionQuery {
	query := (&UserSolutionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usersolution.Table, usersolution.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SolutionsTable, user.SolutionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserActivityClient is a client for the UserActivity schema.
type UserActivityClient struct {
	config
}

// NewUserActivityClient returns a client for the UserActivity from the given config.
func NewUserActivityClient(c config) *UserActivityClient {
	return &UserActivityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `useractivity.Hooks(f(g(h())))`.
func (c *UserActivityClient) Use(hooks ...Hook) {
	c.hooks.UserActivity = append(c.hooks.UserActivity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `useractivity.Intercept(f(g(h())))`.
func (c *UserActivityClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserActivity = append(c.inters.UserActivity, interceptors...)
}

// Create returns a builder for creating a UserActivity entity.
func (c *UserActivityClient) Create() *UserActivityCreate {
	mutation := newUserActivityMutation(c.config, OpCreate)
	return &UserActivityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserActivity entities.
func (c *UserActivityClient) CreateBulk(builders ...*UserActivityCreate) *UserActivityCreateBulk {
	return &UserActivityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserActivityClient) MapCreateBulk(slice any, setFunc func(*UserActivityCreate, int)) *UserActivityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserActivityCreateBulk{err: fmt.Errorf("calling to UserActivityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserActivityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserActivityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserActivity.
func (c *UserActivityClient) Update() *UserActivityUpdate {
	mutation := newUserActivityMutation(c.config, OpUpdate)
	return &UserActivityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserActivityClient) UpdateOne(ua *UserActivity) *UserActivityUpdateOne {
	mutation := newUserActivityMutation(c.config, OpUpdateOne, withUserActivity(ua))
	return &UserActivityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserActivityClient) UpdateOneID(id int) *UserActivityUpdateOne {
	mutation := newUserActivityMutation(c.config, OpUpdateOne, withUserActivityID(id))
	return &UserActivityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserActivity.
func (c *UserActivityClient) Delete() *UserActivityDelete {
	mutation := newUserActivityMutation(c.config, OpDelete)
	return &UserActivityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserActivityClient) DeleteOne(ua *UserActivity) *UserActivityDeleteOne {
	return c.DeleteOneID(ua.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserActivityClient) DeleteOneID(id int) *UserActivityDeleteOne {
	builder := c.Delete().Where(useractivity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserActivityDeleteOne{builder}
}

// Query returns a query builder for UserActivity.
func (c *UserActivityClient) Query() *UserActivityQuery {
	return &UserActivityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserActivity},
		inters: c.Interceptors(),
	}
}

// Get returns a UserActivity entity by its id.
func (c *UserActivityClient) Get(ctx context.Context, id int) (*UserActivity, error) {
	return c.Query().Where(useractivity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserActivityClient) GetX(ctx context.Context, id int) *UserActivity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserActivity.
func (c *UserActivityClient) QueryUser(ua *UserActivity) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ua.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(useractivity.Table, useractivity.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, useractivity.UserTable, useractivity.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ua.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserActivityClient) Hooks() []Hook {
	return c.hooks.UserActivity
}

// Interceptors returns the client interceptors.
func (c *UserActivityClient) Interceptors() []Interceptor {
	return c.inters.UserActivity
}

func (c *UserActivityClient) mutate(ctx context.Context, m *UserActivityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserActivityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserActivityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserActivityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserActivityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserActivity mutation op: %q", m.Op())
	}
}

// UserCareerClient is a client for the UserCareer schema.
type UserCareerClient struct {
	config
}

// NewUserCareerClient returns a client for the UserCareer from the given config.
func NewUserCareerClient(c config) *UserCareerClient {
	return &UserCareerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usercareer.Hooks(f(g(h())))`.
func (c *UserCareerClient) Use(hooks ...Hook) {
	c.hooks.UserCareer = append(c.hooks.UserCareer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usercareer.Intercept(f(g(h())))`.
func (c *UserCareerClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserCareer = append(c.inters.UserCareer, interceptors...)
}

// Create returns a builder for creating a UserCareer entity.
func (c *UserCareerClient) Create() *UserCareerCreate {
	mutation := newUserCareerMutation(c.config, OpCreate)
	return &UserCareerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserCareer entities.
func (c *UserCareerClient) CreateBulk(builders ...*UserCareerCreate) *UserCareerCreateBulk {
	return &UserCareerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserCareerClient) MapCreateBulk(slice any, setFunc func(*UserCareerCreate, int)) *UserCareerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCareerCreateBulk{err: fmt.Errorf("calling to UserCareerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCareerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCareerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserCareer.
func (c *UserCareerClient) Update() *UserCareerUpdate {
	mutation := newUserCareerMutation(c.config, OpUpdate)
	return &UserCareerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserCareerClient) UpdateOne(uc *UserCareer) *UserCareerUpdateOne {
	mutation := newUserCareerMutation(c.config, OpUpdateOne, withUserCareer(uc))
	return &UserCareerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserCareerClient) UpdateOneID(id int) *UserCareerUpdateOne {
	mutation := newUserCareerMutation(c.config, OpUpdateOne, withUserCareerID(id))
	return &UserCareerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserCareer.
func (c *UserCareerClient) Delete() *UserCareerDelete {
	mutation := newUserCareerMutation(c.config, OpDelete)
	return &UserCareerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserCareerClient) DeleteOne(uc *UserCareer) *UserCareerDeleteOne {
	return c.DeleteOneID(uc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserCareerClient) DeleteOneID(id int) *UserCareerDeleteOne {
	builder := c.Delete().Where(usercareer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserCareerDeleteOne{builder}
}

// Query returns a query builder for UserCareer.
func (c *UserCareerClient) Query() *UserCareerQuery {
	return &UserCareerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserCareer},
		inters: c.Interceptors(),
	}
}

// Get returns a UserCareer entity by its id.
func (c *UserCareerClient) Get(ctx context.Context, id int) (*UserCareer, error) {
	return c.Query().Where(usercareer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserCareerClient) GetX(ctx context.Context, id int) *UserCareer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCareerGroup queries the careerGroup edge of a UserCareer.
func (c *UserCareerClient) QueryCareerGroup(uc *UserCareer) *UserCareerGroupQuery {
	query := (&UserCareerGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := uc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usercareer.Table, usercareer.FieldID, id),
			sqlgraph.To(usercareergroup.Table, usercareergroup.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usercareer.CareerGroupTable, usercareer.CareerGroupColumn),
		)
		fromV = sqlgraph.Neighbors(uc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCareerDescriptions queries the careerDescriptions edge of a UserCareer.
func (c *UserCareerClient) QueryCareerDescriptions(uc *UserCareer) *UserCareerDescriptionQuery {
	query := (&UserCareerDescriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := uc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usercareer.Table, usercareer.FieldID, id),
			sqlgraph.To(usercareerdescription.Table, usercareerdescription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, usercareer.CareerDescriptionsTable, usercareer.CareerDescriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(uc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCareerTasks queries the careerTasks edge of a UserCareer.
func (c *UserCareerClient) QueryCareerTasks(uc *UserCareer) *CareerTaskQuery {
	query := (&CareerTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := uc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usercareer.Table, usercareer.FieldID, id),
			sqlgraph.To(careertask.Table, careertask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, usercareer.CareerTasksTable, usercareer.CareerTasksColumn),
		)
		fromV = sqlgraph.Neighbors(uc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCareerSkillGroups queries the careerSkillGroups edge of a UserCareer.
func (c *UserCareerClient) QueryCareerSkillGroups(uc *UserCareer) *CareerSkillGroupQuery {
	query := (&CareerSkillGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := uc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usercareer.Table, usercareer.FieldID, id),
			sqlgraph.To(careerskillgroup.Table, careerskillgroup.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, usercareer.CareerSkillGroupsTable, usercareer.CareerSkillGroupsColumn),
		)
		fromV = sqlgraph.Neighbors(uc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserCareerClient) Hooks() []Hook {
	return c.hooks.UserCareer
}

// Interceptors returns the client interceptors.
func (c *UserCareerClient) Interceptors() []Interceptor {
	return c.inters.UserCareer
}

func (c *UserCareerClient) mutate(ctx context.Context, m *UserCareerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCareerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserCareerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserCareerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserCareerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserCareer mutation op: %q", m.Op())
	}
}

// UserCareerDescriptionClient is a client for the UserCareerDescription schema.
type UserCareerDescriptionClient struct {
	config
}

// NewUserCareerDescriptionClient returns a client for the UserCareerDescription from the given config.
func NewUserCareerDescriptionClient(c config) *UserCareerDescriptionClient {
	return &UserCareerDescriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usercareerdescription.Hooks(f(g(h())))`.
func (c *UserCareerDescriptionClient) Use(hooks ...Hook) {
	c.hooks.UserCareerDescription = append(c.hooks.UserCareerDescription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usercareerdescription.Intercept(f(g(h())))`.
func (c *UserCareerDescriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserCareerDescription = append(c.inters.UserCareerDescription, interceptors...)
}

// Create returns a builder for creating a UserCareerDescription entity.
func (c *UserCareerDescriptionClient) Create() *UserCareerDescriptionCreate {
	mutation := newUserCareerDescriptionMutation(c.config, OpCreate)
	return &UserCareerDescriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserCareerDescription entities.
func (c *UserCareerDescriptionClient) CreateBulk(builders ...*UserCareerDescriptionCreate) *UserCareerDescriptionCreateBulk {
	return &UserCareerDescriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserCareerDescriptionClient) MapCreateBulk(slice any, setFunc func(*UserCareerDescriptionCreate, int)) *UserCareerDescriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCareerDescriptionCreateBulk{err: fmt.Errorf("calling to UserCareerDescriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCareerDescriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCareerDescriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserCareerDescription.
func (c *UserCareerDescriptionClient) Update() *UserCareerDescriptionUpdate {
	mutation := newUserCareerDescriptionMutation(c.config, OpUpdate)
	return &UserCareerDescriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserCareerDescriptionClient) UpdateOne(ucd *UserCareerDescription) *UserCareerDescriptionUpdateOne {
	mutation := newUserCareerDescriptionMutation(c.config, OpUpdateOne, withUserCareerDescription(ucd))
	return &UserCareerDescriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserCareerDescriptionClient) UpdateOneID(id int) *UserCareerDescriptionUpdateOne {
	mutation := newUserCareerDescriptionMutation(c.config, OpUpdateOne, withUserCareerDescriptionID(id))
	return &UserCareerDescriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserCareerDescription.
func (c *UserCareerDescriptionClient) Delete() *UserCareerDescriptionDelete {
	mutation := newUserCareerDescriptionMutation(c.config, OpDelete)
	return &UserCareerDescriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserCareerDescriptionClient) DeleteOne(ucd *UserCareerDescription) *UserCareerDescriptionDeleteOne {
	return c.DeleteOneID(ucd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserCareerDescriptionClient) DeleteOneID(id int) *UserCareerDescriptionDeleteOne {
	builder := c.Delete().Where(usercareerdescription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserCareerDescriptionDeleteOne{builder}
}

// Query returns a query builder for UserCareerDescription.
func (c *UserCareerDescriptionClient) Query() *UserCareerDescriptionQuery {
	return &UserCareerDescriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserCareerDescription},
		inters: c.Interceptors(),
	}
}

// Get returns a UserCareerDescription entity by its id.
func (c *UserCareerDescriptionClient) Get(ctx context.Context, id int) (*UserCareerDescription, error) {
	return c.Query().Where(usercareerdescription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserCareerDescriptionClient) GetX(ctx context.Context, id int) *UserCareerDescription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCareer queries the career edge of a UserCareerDescription.
func (c *UserCareerDescriptionClient) QueryCareer(ucd *UserCareerDescription) *UserCareerQuery {
	query := (&UserCareerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ucd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usercareerdescription.Table, usercareerdescription.FieldID, id),
			sqlgraph.To(usercareer.Table, usercareer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usercareerdescription.CareerTable, usercareerdescription.CareerColumn),
		)
		fromV = sqlgraph.Neighbors(ucd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserCareerDescriptionClient) Hooks() []Hook {
	return c.hooks.UserCareerDescription
}

// Interceptors returns the client interceptors.
func (c *UserCareerDescriptionClient) Interceptors() []Interceptor {
	return c.inters.UserCareerDescription
}

func (c *UserCareerDescriptionClient) mutate(ctx context.Context, m *UserCareerDescriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCareerDescriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserCareerDescriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserCareerDescriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserCareerDescriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserCareerDescription mutation op: %q", m.Op())
	}
}

// UserCareerGroupClient is a client for the UserCareerGroup schema.
type UserCareerGroupClient struct {
	config
}

// NewUserCareerGroupClient returns a client for the UserCareerGroup from the given config.
func NewUserCareerGroupClient(c config) *UserCareerGroupClient {
	return &UserCareerGroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usercareergroup.Hooks(f(g(h())))`.
func (c *UserCareerGroupClient) Use(hooks ...Hook) {
	c.hooks.UserCareerGroup = append(c.hooks.UserCareerGroup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usercareergroup.Intercept(f(g(h())))`.
func (c *UserCareerGroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserCareerGroup = append(c.inters.UserCareerGroup, interceptors...)
}

// Create returns a builder for creating a UserCareerGroup entity.
func (c *UserCareerGroupClient) Create() *UserCareerGroupCreate {
	mutation := newUserCareerGroupMutation(c.config, OpCreate)
	return &UserCareerGroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserCareerGroup entities.
func (c *UserCareerGroupClient) CreateBulk(builders ...*UserCareerGroupCreate) *UserCareerGroupCreateBulk {
	return &UserCareerGroupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserCareerGroupClient) MapCreateBulk(slice any, setFunc func(*UserCareerGroupCreate, int)) *UserCareerGroupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCareerGroupCreateBulk{err: fmt.Errorf("calling to UserCareerGroupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCareerGroupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCareerGroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserCareerGroup.
func (c *UserCareerGroupClient) Update() *UserCareerGroupUpdate {
	mutation := newUserCareerGroupMutation(c.config, OpUpdate)
	return &UserCareerGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserCareerGroupClient) UpdateOne(ucg *UserCareerGroup) *UserCareerGroupUpdateOne {
	mutation := newUserCareerGroupMutation(c.config, OpUpdateOne, withUserCareerGroup(ucg))
	return &UserCareerGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserCareerGroupClient) UpdateOneID(id int) *UserCareerGroupUpdateOne {
	mutation := newUserCareerGroupMutation(c.config, OpUpdateOne, withUserCareerGroupID(id))
	return &UserCareerGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserCareerGroup.
func (c *UserCareerGroupClient) Delete() *UserCareerGroupDelete {
	mutation := newUserCareerGroupMutation(c.config, OpDelete)
	return &UserCareerGroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserCareerGroupClient) DeleteOne(ucg *UserCareerGroup) *UserCareerGroupDeleteOne {
	return c.DeleteOneID(ucg.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserCareerGroupClient) DeleteOneID(id int) *UserCareerGroupDeleteOne {
	builder := c.Delete().Where(usercareergroup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserCareerGroupDeleteOne{builder}
}

// Query returns a query builder for UserCareerGroup.
func (c *UserCareerGroupClient) Query() *UserCareerGroupQuery {
	return &UserCareerGroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserCareerGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a UserCareerGroup entity by its id.
func (c *UserCareerGroupClient) Get(ctx context.Context, id int) (*UserCareerGroup, error) {
	return c.Query().Where(usercareergroup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserCareerGroupClient) GetX(ctx context.Context, id int) *UserCareerGroup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserCareerGroup.
func (c *UserCareerGroupClient) QueryUser(ucg *UserCareerGroup) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ucg.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usercareergroup.Table, usercareergroup.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usercareergroup.UserTable, usercareergroup.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ucg.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCareers queries the careers edge of a UserCareerGroup.
func (c *UserCareerGroupClient) QueryCareers(ucg *UserCareerGroup) *UserCareerQuery {
	query := (&UserCareerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ucg.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usercareergroup.Table, usercareergroup.FieldID, id),
			sqlgraph.To(usercareer.Table, usercareer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, usercareergroup.CareersTable, usercareergroup.CareersColumn),
		)
		fromV = sqlgraph.Neighbors(ucg.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserCareerGroupClient) Hooks() []Hook {
	return c.hooks.UserCareerGroup
}

// Interceptors returns the client interceptors.
func (c *UserCareerGroupClient) Interceptors() []Interceptor {
	return c.inters.UserCareerGroup
}

func (c *UserCareerGroupClient) mutate(ctx context.Context, m *UserCareerGroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCareerGroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserCareerGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserCareerGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserCareerGroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserCareerGroup mutation op: %q", m.Op())
	}
}

// UserNoteClient is a client for the UserNote schema.
type UserNoteClient struct {
	config
}

// NewUserNoteClient returns a client for the UserNote from the given config.
func NewUserNoteClient(c config) *UserNoteClient {
	return &UserNoteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usernote.Hooks(f(g(h())))`.
func (c *UserNoteClient) Use(hooks ...Hook) {
	c.hooks.UserNote = append(c.hooks.UserNote, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usernote.Intercept(f(g(h())))`.
func (c *UserNoteClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserNote = append(c.inters.UserNote, interceptors...)
}

// Create returns a builder for creating a UserNote entity.
func (c *UserNoteClient) Create() *UserNoteCreate {
	mutation := newUserNoteMutation(c.config, OpCreate)
	return &UserNoteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserNote entities.
func (c *UserNoteClient) CreateBulk(builders ...*UserNoteCreate) *UserNoteCreateBulk {
	return &UserNoteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserNoteClient) MapCreateBulk(slice any, setFunc func(*UserNoteCreate, int)) *UserNoteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserNoteCreateBulk{err: fmt.Errorf("calling to UserNoteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserNoteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserNoteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserNote.
func (c *UserNoteClient) Update() *UserNoteUpdate {
	mutation := newUserNoteMutation(c.config, OpUpdate)
	return &UserNoteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserNoteClient) UpdateOne(un *UserNote) *UserNoteUpdateOne {
	mutation := newUserNoteMutation(c.config, OpUpdateOne, withUserNote(un))
	return &UserNoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserNoteClient) UpdateOneID(id int) *UserNoteUpdateOne {
	mutation := newUserNoteMutation(c.config, OpUpdateOne, withUserNoteID(id))
	return &UserNoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserNote.
func (c *UserNoteClient) Delete() *UserNoteDelete {
	mutation := newUserNoteMutation(c.config, OpDelete)
	return &UserNoteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserNoteClient) DeleteOne(un *UserNote) *UserNoteDeleteOne {
	return c.DeleteOneID(un.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserNoteClient) DeleteOneID(id int) *UserNoteDeleteOne {
	builder := c.Delete().Where(usernote.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserNoteDeleteOne{builder}
}

// Query returns a query builder for UserNote.
func (c *UserNoteClient) Query() *UserNoteQuery {
	return &UserNoteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserNote},
		inters: c.Interceptors(),
	}
}

// Get returns a UserNote entity by its id.
func (c *UserNoteClient) Get(ctx context.Context, id int) (*UserNote, error) {
	return c.Query().Where(usernote.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserNoteClient) GetX(ctx context.Context, id int) *UserNote {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserNote.
func (c *UserNoteClient) QueryUser(un *UserNote) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := un.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usernote.Table, usernote.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usernote.UserTable, usernote.UserColumn),
		)
		fromV = sqlgraph.Neighbors(un.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNoteItems queries the noteItems edge of a UserNote.
func (c *UserNoteClient) QueryNoteItems(un *UserNote) *UserNoteItemQuery {
	query := (&UserNoteItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := un.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usernote.Table, usernote.FieldID, id),
			sqlgraph.To(usernoteitem.Table, usernoteitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, usernote.NoteItemsTable, usernote.NoteItemsColumn),
		)
		fromV = sqlgraph.Neighbors(un.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserNoteClient) Hooks() []Hook {
	return c.hooks.UserNote
}

// Interceptors returns the client interceptors.
func (c *UserNoteClient) Interceptors() []Interceptor {
	return c.inters.UserNote
}

func (c *UserNoteClient) mutate(ctx context.Context, m *UserNoteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserNoteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserNoteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserNoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserNoteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserNote mutation op: %q", m.Op())
	}
}

// UserNoteItemClient is a client for the UserNoteItem schema.
type UserNoteItemClient struct {
	config
}

// NewUserNoteItemClient returns a client for the UserNoteItem from the given config.
func NewUserNoteItemClient(c config) *UserNoteItemClient {
	return &UserNoteItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usernoteitem.Hooks(f(g(h())))`.
func (c *UserNoteItemClient) Use(hooks ...Hook) {
	c.hooks.UserNoteItem = append(c.hooks.UserNoteItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usernoteitem.Intercept(f(g(h())))`.
func (c *UserNoteItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserNoteItem = append(c.inters.UserNoteItem, interceptors...)
}

// Create returns a builder for creating a UserNoteItem entity.
func (c *UserNoteItemClient) Create() *UserNoteItemCreate {
	mutation := newUserNoteItemMutation(c.config, OpCreate)
	return &UserNoteItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserNoteItem entities.
func (c *UserNoteItemClient) CreateBulk(builders ...*UserNoteItemCreate) *UserNoteItemCreateBulk {
	return &UserNoteItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserNoteItemClient) MapCreateBulk(slice any, setFunc func(*UserNoteItemCreate, int)) *UserNoteItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserNoteItemCreateBulk{err: fmt.Errorf("calling to UserNoteItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserNoteItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserNoteItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserNoteItem.
func (c *UserNoteItemClient) Update() *UserNoteItemUpdate {
	mutation := newUserNoteItemMutation(c.config, OpUpdate)
	return &UserNoteItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserNoteItemClient) UpdateOne(uni *UserNoteItem) *UserNoteItemUpdateOne {
	mutation := newUserNoteItemMutation(c.config, OpUpdateOne, withUserNoteItem(uni))
	return &UserNoteItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserNoteItemClient) UpdateOneID(id int) *UserNoteItemUpdateOne {
	mutation := newUserNoteItemMutation(c.config, OpUpdateOne, withUserNoteItemID(id))
	return &UserNoteItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserNoteItem.
func (c *UserNoteItemClient) Delete() *UserNoteItemDelete {
	mutation := newUserNoteItemMutation(c.config, OpDelete)
	return &UserNoteItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserNoteItemClient) DeleteOne(uni *UserNoteItem) *UserNoteItemDeleteOne {
	return c.DeleteOneID(uni.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserNoteItemClient) DeleteOneID(id int) *UserNoteItemDeleteOne {
	builder := c.Delete().Where(usernoteitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserNoteItemDeleteOne{builder}
}

// Query returns a query builder for UserNoteItem.
func (c *UserNoteItemClient) Query() *UserNoteItemQuery {
	return &UserNoteItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserNoteItem},
		inters: c.Interceptors(),
	}
}

// Get returns a UserNoteItem entity by its id.
func (c *UserNoteItemClient) Get(ctx context.Context, id int) (*UserNoteItem, error) {
	return c.Query().Where(usernoteitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserNoteItemClient) GetX(ctx context.Context, id int) *UserNoteItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNote queries the note edge of a UserNoteItem.
func (c *UserNoteItemClient) QueryNote(uni *UserNoteItem) *UserNoteQuery {
	query := (&UserNoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := uni.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usernoteitem.Table, usernoteitem.FieldID, id),
			sqlgraph.To(usernote.Table, usernote.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usernoteitem.NoteTable, usernoteitem.NoteColumn),
		)
		fromV = sqlgraph.Neighbors(uni.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserNoteItemClient) Hooks() []Hook {
	return c.hooks.UserNoteItem
}

// Interceptors returns the client interceptors.
func (c *UserNoteItemClient) Interceptors() []Interceptor {
	return c.inters.UserNoteItem
}

func (c *UserNoteItemClient) mutate(ctx context.Context, m *UserNoteItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserNoteItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserNoteItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserNoteItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserNoteItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserNoteItem mutation op: %q", m.Op())
	}
}

// UserQualificationClient is a client for the UserQualification schema.
type UserQualificationClient struct {
	config
}

// NewUserQualificationClient returns a client for the UserQualification from the given config.
func NewUserQualificationClient(c config) *UserQualificationClient {
	return &UserQualificationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userqualification.Hooks(f(g(h())))`.
func (c *UserQualificationClient) Use(hooks ...Hook) {
	c.hooks.UserQualification = append(c.hooks.UserQualification, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userqualification.Intercept(f(g(h())))`.
func (c *UserQualificationClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserQualification = append(c.inters.UserQualification, interceptors...)
}

// Create returns a builder for creating a UserQualification entity.
func (c *UserQualificationClient) Create() *UserQualificationCreate {
	mutation := newUserQualificationMutation(c.config, OpCreate)
	return &UserQualificationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserQualification entities.
func (c *UserQualificationClient) CreateBulk(builders ...*UserQualificationCreate) *UserQualificationCreateBulk {
	return &UserQualificationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserQualificationClient) MapCreateBulk(slice any, setFunc func(*UserQualificationCreate, int)) *UserQualificationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserQualificationCreateBulk{err: fmt.Errorf("calling to UserQualificationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserQualificationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserQualificationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserQualification.
func (c *UserQualificationClient) Update() *UserQualificationUpdate {
	mutation := newUserQualificationMutation(c.config, OpUpdate)
	return &UserQualificationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserQualificationClient) UpdateOne(uq *UserQualification) *UserQualificationUpdateOne {
	mutation := newUserQualificationMutation(c.config, OpUpdateOne, withUserQualification(uq))
	return &UserQualificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserQualificationClient) UpdateOneID(id int) *UserQualificationUpdateOne {
	mutation := newUserQualificationMutation(c.config, OpUpdateOne, withUserQualificationID(id))
	return &UserQualificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserQualification.
func (c *UserQualificationClient) Delete() *UserQualificationDelete {
	mutation := newUserQualificationMutation(c.config, OpDelete)
	return &UserQualificationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserQualificationClient) DeleteOne(uq *UserQualification) *UserQualificationDeleteOne {
	return c.DeleteOneID(uq.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserQualificationClient) DeleteOneID(id int) *UserQualificationDeleteOne {
	builder := c.Delete().Where(userqualification.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserQualificationDeleteOne{builder}
}

// Query returns a query builder for UserQualification.
func (c *UserQualificationClient) Query() *UserQualificationQuery {
	return &UserQualificationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserQualification},
		inters: c.Interceptors(),
	}
}

// Get returns a UserQualification entity by its id.
func (c *UserQualificationClient) Get(ctx context.Context, id int) (*UserQualification, error) {
	return c.Query().Where(userqualification.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserQualificationClient) GetX(ctx context.Context, id int) *UserQualification {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserQualification.
func (c *UserQualificationClient) QueryUser(uq *UserQualification) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := uq.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userqualification.Table, userqualification.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userqualification.UserTable, userqualification.UserColumn),
		)
		fromV = sqlgraph.Neighbors(uq.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserQualificationClient) Hooks() []Hook {
	return c.hooks.UserQualification
}

// Interceptors returns the client interceptors.
func (c *UserQualificationClient) Interceptors() []Interceptor {
	return c.inters.UserQualification
}

func (c *UserQualificationClient) mutate(ctx context.Context, m *UserQualificationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserQualificationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserQualificationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserQualificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserQualificationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserQualification mutation op: %q", m.Op())
	}
}

// UserSolutionClient is a client for the UserSolution schema.
type UserSolutionClient struct {
	config
}

// NewUserSolutionClient returns a client for the UserSolution from the given config.
func NewUserSolutionClient(c config) *UserSolutionClient {
	return &UserSolutionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usersolution.Hooks(f(g(h())))`.
func (c *UserSolutionClient) Use(hooks ...Hook) {
	c.hooks.UserSolution = append(c.hooks.UserSolution, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usersolution.Intercept(f(g(h())))`.
func (c *UserSolutionClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserSolution = append(c.inters.UserSolution, interceptors...)
}

// Create returns a builder for creating a UserSolution entity.
func (c *UserSolutionClient) Create() *UserSolutionCreate {
	mutation := newUserSolutionMutation(c.config, OpCreate)
	return &UserSolutionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserSolution entities.
func (c *UserSolutionClient) CreateBulk(builders ...*UserSolutionCreate) *UserSolutionCreateBulk {
	return &UserSolutionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserSolutionClient) MapCreateBulk(slice any, setFunc func(*UserSolutionCreate, int)) *UserSolutionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserSolutionCreateBulk{err: fmt.Errorf("calling to UserSolutionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserSolutionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserSolutionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserSolution.
func (c *UserSolutionClient) Update() *UserSolutionUpdate {
	mutation := newUserSolutionMutation(c.config, OpUpdate)
	return &UserSolutionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserSolutionClient) UpdateOne(us *UserSolution) *UserSolutionUpdateOne {
	mutation := newUserSolutionMutation(c.config, OpUpdateOne, withUserSolution(us))
	return &UserSolutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserSolutionClient) UpdateOneID(id int) *UserSolutionUpdateOne {
	mutation := newUserSolutionMutation(c.config, OpUpdateOne, withUserSolutionID(id))
	return &UserSolutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserSolution.
func (c *UserSolutionClient) Delete() *UserSolutionDelete {
	mutation := newUserSolutionMutation(c.config, OpDelete)
	return &UserSolutionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserSolutionClient) DeleteOne(us *UserSolution) *UserSolutionDeleteOne {
	return c.DeleteOneID(us.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserSolutionClient) DeleteOneID(id int) *UserSolutionDeleteOne {
	builder := c.Delete().Where(usersolution.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserSolutionDeleteOne{builder}
}

// Query returns a query builder for UserSolution.
func (c *UserSolutionClient) Query() *UserSolutionQuery {
	return &UserSolutionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserSolution},
		inters: c.Interceptors(),
	}
}

// Get returns a UserSolution entity by its id.
func (c *UserSolutionClient) Get(ctx context.Context, id int) (*UserSolution, error) {
	return c.Query().Where(usersolution.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserSolutionClient) GetX(ctx context.Context, id int) *UserSolution {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserSolution.
func (c *UserSolutionClient) QueryUser(us *UserSolution) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := us.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usersolution.Table, usersolution.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usersolution.UserTable, usersolution.UserColumn),
		)
		fromV = sqlgraph.Neighbors(us.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserSolutionClient) Hooks() []Hook {
	return c.hooks.UserSolution
}

// Interceptors returns the client interceptors.
func (c *UserSolutionClient) Interceptors() []Interceptor {
	return c.inters.UserSolution
}

func (c *UserSolutionClient) mutate(ctx context.Context, m *UserSolutionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserSolutionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserSolutionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserSolutionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserSolutionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserSolution mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		CareerSkill, CareerSkillGroup, CareerTask, CareerTaskDescription, Skill,
		SkillTag, User, UserActivity, UserCareer, UserCareerDescription,
		UserCareerGroup, UserNote, UserNoteItem, UserQualification,
		UserSolution []ent.Hook
	}
	inters struct {
		CareerSkill, CareerSkillGroup, CareerTask, CareerTaskDescription, Skill,
		SkillTag, User, UserActivity, UserCareer, UserCareerDescription,
		UserCareerGroup, UserNote, UserNoteItem, UserQualification,
		UserSolution []ent.Interceptor
	}
)
