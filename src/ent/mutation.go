// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/sky0621/cv-admin/src/ent/careerskill"
	"github.com/sky0621/cv-admin/src/ent/careerskillgroup"
	"github.com/sky0621/cv-admin/src/ent/careertask"
	"github.com/sky0621/cv-admin/src/ent/careertaskdescription"
	"github.com/sky0621/cv-admin/src/ent/predicate"
	"github.com/sky0621/cv-admin/src/ent/skill"
	"github.com/sky0621/cv-admin/src/ent/skilltag"
	"github.com/sky0621/cv-admin/src/ent/user"
	"github.com/sky0621/cv-admin/src/ent/useractivity"
	"github.com/sky0621/cv-admin/src/ent/usercareer"
	"github.com/sky0621/cv-admin/src/ent/usercareerdescription"
	"github.com/sky0621/cv-admin/src/ent/usercareergroup"
	"github.com/sky0621/cv-admin/src/ent/usernote"
	"github.com/sky0621/cv-admin/src/ent/usernoteitem"
	"github.com/sky0621/cv-admin/src/ent/userqualification"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCareerSkill           = "CareerSkill"
	TypeCareerSkillGroup      = "CareerSkillGroup"
	TypeCareerTask            = "CareerTask"
	TypeCareerTaskDescription = "CareerTaskDescription"
	TypeSkill                 = "Skill"
	TypeSkillTag              = "SkillTag"
	TypeUser                  = "User"
	TypeUserActivity          = "UserActivity"
	TypeUserCareer            = "UserCareer"
	TypeUserCareerDescription = "UserCareerDescription"
	TypeUserCareerGroup       = "UserCareerGroup"
	TypeUserNote              = "UserNote"
	TypeUserNoteItem          = "UserNoteItem"
	TypeUserQualification     = "UserQualification"
)

// CareerSkillMutation represents an operation that mutates the CareerSkill nodes in the graph.
type CareerSkillMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	create_time             *time.Time
	update_time             *time.Time
	version                 *string
	clearedFields           map[string]struct{}
	careerSkillGroup        *int
	clearedcareerSkillGroup bool
	skill                   *int
	clearedskill            bool
	done                    bool
	oldValue                func(context.Context) (*CareerSkill, error)
	predicates              []predicate.CareerSkill
}

var _ ent.Mutation = (*CareerSkillMutation)(nil)

// careerskillOption allows management of the mutation configuration using functional options.
type careerskillOption func(*CareerSkillMutation)

// newCareerSkillMutation creates new mutation for the CareerSkill entity.
func newCareerSkillMutation(c config, op Op, opts ...careerskillOption) *CareerSkillMutation {
	m := &CareerSkillMutation{
		config:        c,
		op:            op,
		typ:           TypeCareerSkill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCareerSkillID sets the ID field of the mutation.
func withCareerSkillID(id int) careerskillOption {
	return func(m *CareerSkillMutation) {
		var (
			err   error
			once  sync.Once
			value *CareerSkill
		)
		m.oldValue = func(ctx context.Context) (*CareerSkill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CareerSkill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCareerSkill sets the old CareerSkill of the mutation.
func withCareerSkill(node *CareerSkill) careerskillOption {
	return func(m *CareerSkillMutation) {
		m.oldValue = func(context.Context) (*CareerSkill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CareerSkillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CareerSkillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CareerSkillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CareerSkillMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CareerSkill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CareerSkillMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CareerSkillMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CareerSkill entity.
// If the CareerSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CareerSkillMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CareerSkillMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CareerSkillMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CareerSkillMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CareerSkill entity.
// If the CareerSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CareerSkillMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CareerSkillMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetVersion sets the "version" field.
func (m *CareerSkillMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *CareerSkillMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the CareerSkill entity.
// If the CareerSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CareerSkillMutation) OldVersion(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *CareerSkillMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[careerskill.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *CareerSkillMutation) VersionCleared() bool {
	_, ok := m.clearedFields[careerskill.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *CareerSkillMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, careerskill.FieldVersion)
}

// SetCareerSkillGroupID sets the "careerSkillGroup" edge to the CareerSkillGroup entity by id.
func (m *CareerSkillMutation) SetCareerSkillGroupID(id int) {
	m.careerSkillGroup = &id
}

// ClearCareerSkillGroup clears the "careerSkillGroup" edge to the CareerSkillGroup entity.
func (m *CareerSkillMutation) ClearCareerSkillGroup() {
	m.clearedcareerSkillGroup = true
}

// CareerSkillGroupCleared reports if the "careerSkillGroup" edge to the CareerSkillGroup entity was cleared.
func (m *CareerSkillMutation) CareerSkillGroupCleared() bool {
	return m.clearedcareerSkillGroup
}

// CareerSkillGroupID returns the "careerSkillGroup" edge ID in the mutation.
func (m *CareerSkillMutation) CareerSkillGroupID() (id int, exists bool) {
	if m.careerSkillGroup != nil {
		return *m.careerSkillGroup, true
	}
	return
}

// CareerSkillGroupIDs returns the "careerSkillGroup" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CareerSkillGroupID instead. It exists only for internal usage by the builders.
func (m *CareerSkillMutation) CareerSkillGroupIDs() (ids []int) {
	if id := m.careerSkillGroup; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCareerSkillGroup resets all changes to the "careerSkillGroup" edge.
func (m *CareerSkillMutation) ResetCareerSkillGroup() {
	m.careerSkillGroup = nil
	m.clearedcareerSkillGroup = false
}

// SetSkillID sets the "skill" edge to the Skill entity by id.
func (m *CareerSkillMutation) SetSkillID(id int) {
	m.skill = &id
}

// ClearSkill clears the "skill" edge to the Skill entity.
func (m *CareerSkillMutation) ClearSkill() {
	m.clearedskill = true
}

// SkillCleared reports if the "skill" edge to the Skill entity was cleared.
func (m *CareerSkillMutation) SkillCleared() bool {
	return m.clearedskill
}

// SkillID returns the "skill" edge ID in the mutation.
func (m *CareerSkillMutation) SkillID() (id int, exists bool) {
	if m.skill != nil {
		return *m.skill, true
	}
	return
}

// SkillIDs returns the "skill" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SkillID instead. It exists only for internal usage by the builders.
func (m *CareerSkillMutation) SkillIDs() (ids []int) {
	if id := m.skill; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSkill resets all changes to the "skill" edge.
func (m *CareerSkillMutation) ResetSkill() {
	m.skill = nil
	m.clearedskill = false
}

// Where appends a list predicates to the CareerSkillMutation builder.
func (m *CareerSkillMutation) Where(ps ...predicate.CareerSkill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CareerSkillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CareerSkillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CareerSkill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CareerSkillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CareerSkillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CareerSkill).
func (m *CareerSkillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CareerSkillMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, careerskill.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, careerskill.FieldUpdateTime)
	}
	if m.version != nil {
		fields = append(fields, careerskill.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CareerSkillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case careerskill.FieldCreateTime:
		return m.CreateTime()
	case careerskill.FieldUpdateTime:
		return m.UpdateTime()
	case careerskill.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CareerSkillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case careerskill.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case careerskill.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case careerskill.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown CareerSkill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CareerSkillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case careerskill.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case careerskill.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case careerskill.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown CareerSkill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CareerSkillMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CareerSkillMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CareerSkillMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CareerSkill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CareerSkillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(careerskill.FieldVersion) {
		fields = append(fields, careerskill.FieldVersion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CareerSkillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CareerSkillMutation) ClearField(name string) error {
	switch name {
	case careerskill.FieldVersion:
		m.ClearVersion()
		return nil
	}
	return fmt.Errorf("unknown CareerSkill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CareerSkillMutation) ResetField(name string) error {
	switch name {
	case careerskill.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case careerskill.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case careerskill.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown CareerSkill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CareerSkillMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.careerSkillGroup != nil {
		edges = append(edges, careerskill.EdgeCareerSkillGroup)
	}
	if m.skill != nil {
		edges = append(edges, careerskill.EdgeSkill)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CareerSkillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case careerskill.EdgeCareerSkillGroup:
		if id := m.careerSkillGroup; id != nil {
			return []ent.Value{*id}
		}
	case careerskill.EdgeSkill:
		if id := m.skill; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CareerSkillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CareerSkillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CareerSkillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcareerSkillGroup {
		edges = append(edges, careerskill.EdgeCareerSkillGroup)
	}
	if m.clearedskill {
		edges = append(edges, careerskill.EdgeSkill)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CareerSkillMutation) EdgeCleared(name string) bool {
	switch name {
	case careerskill.EdgeCareerSkillGroup:
		return m.clearedcareerSkillGroup
	case careerskill.EdgeSkill:
		return m.clearedskill
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CareerSkillMutation) ClearEdge(name string) error {
	switch name {
	case careerskill.EdgeCareerSkillGroup:
		m.ClearCareerSkillGroup()
		return nil
	case careerskill.EdgeSkill:
		m.ClearSkill()
		return nil
	}
	return fmt.Errorf("unknown CareerSkill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CareerSkillMutation) ResetEdge(name string) error {
	switch name {
	case careerskill.EdgeCareerSkillGroup:
		m.ResetCareerSkillGroup()
		return nil
	case careerskill.EdgeSkill:
		m.ResetSkill()
		return nil
	}
	return fmt.Errorf("unknown CareerSkill edge %s", name)
}

// CareerSkillGroupMutation represents an operation that mutates the CareerSkillGroup nodes in the graph.
type CareerSkillGroupMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	create_time         *time.Time
	update_time         *time.Time
	label               *string
	clearedFields       map[string]struct{}
	career              *int
	clearedcareer       bool
	careerSkills        map[int]struct{}
	removedcareerSkills map[int]struct{}
	clearedcareerSkills bool
	done                bool
	oldValue            func(context.Context) (*CareerSkillGroup, error)
	predicates          []predicate.CareerSkillGroup
}

var _ ent.Mutation = (*CareerSkillGroupMutation)(nil)

// careerskillgroupOption allows management of the mutation configuration using functional options.
type careerskillgroupOption func(*CareerSkillGroupMutation)

// newCareerSkillGroupMutation creates new mutation for the CareerSkillGroup entity.
func newCareerSkillGroupMutation(c config, op Op, opts ...careerskillgroupOption) *CareerSkillGroupMutation {
	m := &CareerSkillGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeCareerSkillGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCareerSkillGroupID sets the ID field of the mutation.
func withCareerSkillGroupID(id int) careerskillgroupOption {
	return func(m *CareerSkillGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *CareerSkillGroup
		)
		m.oldValue = func(ctx context.Context) (*CareerSkillGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CareerSkillGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCareerSkillGroup sets the old CareerSkillGroup of the mutation.
func withCareerSkillGroup(node *CareerSkillGroup) careerskillgroupOption {
	return func(m *CareerSkillGroupMutation) {
		m.oldValue = func(context.Context) (*CareerSkillGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CareerSkillGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CareerSkillGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CareerSkillGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CareerSkillGroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CareerSkillGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CareerSkillGroupMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CareerSkillGroupMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CareerSkillGroup entity.
// If the CareerSkillGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CareerSkillGroupMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CareerSkillGroupMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CareerSkillGroupMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CareerSkillGroupMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CareerSkillGroup entity.
// If the CareerSkillGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CareerSkillGroupMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CareerSkillGroupMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetLabel sets the "label" field.
func (m *CareerSkillGroupMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *CareerSkillGroupMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the CareerSkillGroup entity.
// If the CareerSkillGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CareerSkillGroupMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *CareerSkillGroupMutation) ResetLabel() {
	m.label = nil
}

// SetCareerID sets the "career" edge to the UserCareer entity by id.
func (m *CareerSkillGroupMutation) SetCareerID(id int) {
	m.career = &id
}

// ClearCareer clears the "career" edge to the UserCareer entity.
func (m *CareerSkillGroupMutation) ClearCareer() {
	m.clearedcareer = true
}

// CareerCleared reports if the "career" edge to the UserCareer entity was cleared.
func (m *CareerSkillGroupMutation) CareerCleared() bool {
	return m.clearedcareer
}

// CareerID returns the "career" edge ID in the mutation.
func (m *CareerSkillGroupMutation) CareerID() (id int, exists bool) {
	if m.career != nil {
		return *m.career, true
	}
	return
}

// CareerIDs returns the "career" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CareerID instead. It exists only for internal usage by the builders.
func (m *CareerSkillGroupMutation) CareerIDs() (ids []int) {
	if id := m.career; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCareer resets all changes to the "career" edge.
func (m *CareerSkillGroupMutation) ResetCareer() {
	m.career = nil
	m.clearedcareer = false
}

// AddCareerSkillIDs adds the "careerSkills" edge to the CareerSkill entity by ids.
func (m *CareerSkillGroupMutation) AddCareerSkillIDs(ids ...int) {
	if m.careerSkills == nil {
		m.careerSkills = make(map[int]struct{})
	}
	for i := range ids {
		m.careerSkills[ids[i]] = struct{}{}
	}
}

// ClearCareerSkills clears the "careerSkills" edge to the CareerSkill entity.
func (m *CareerSkillGroupMutation) ClearCareerSkills() {
	m.clearedcareerSkills = true
}

// CareerSkillsCleared reports if the "careerSkills" edge to the CareerSkill entity was cleared.
func (m *CareerSkillGroupMutation) CareerSkillsCleared() bool {
	return m.clearedcareerSkills
}

// RemoveCareerSkillIDs removes the "careerSkills" edge to the CareerSkill entity by IDs.
func (m *CareerSkillGroupMutation) RemoveCareerSkillIDs(ids ...int) {
	if m.removedcareerSkills == nil {
		m.removedcareerSkills = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.careerSkills, ids[i])
		m.removedcareerSkills[ids[i]] = struct{}{}
	}
}

// RemovedCareerSkills returns the removed IDs of the "careerSkills" edge to the CareerSkill entity.
func (m *CareerSkillGroupMutation) RemovedCareerSkillsIDs() (ids []int) {
	for id := range m.removedcareerSkills {
		ids = append(ids, id)
	}
	return
}

// CareerSkillsIDs returns the "careerSkills" edge IDs in the mutation.
func (m *CareerSkillGroupMutation) CareerSkillsIDs() (ids []int) {
	for id := range m.careerSkills {
		ids = append(ids, id)
	}
	return
}

// ResetCareerSkills resets all changes to the "careerSkills" edge.
func (m *CareerSkillGroupMutation) ResetCareerSkills() {
	m.careerSkills = nil
	m.clearedcareerSkills = false
	m.removedcareerSkills = nil
}

// Where appends a list predicates to the CareerSkillGroupMutation builder.
func (m *CareerSkillGroupMutation) Where(ps ...predicate.CareerSkillGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CareerSkillGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CareerSkillGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CareerSkillGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CareerSkillGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CareerSkillGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CareerSkillGroup).
func (m *CareerSkillGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CareerSkillGroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, careerskillgroup.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, careerskillgroup.FieldUpdateTime)
	}
	if m.label != nil {
		fields = append(fields, careerskillgroup.FieldLabel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CareerSkillGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case careerskillgroup.FieldCreateTime:
		return m.CreateTime()
	case careerskillgroup.FieldUpdateTime:
		return m.UpdateTime()
	case careerskillgroup.FieldLabel:
		return m.Label()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CareerSkillGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case careerskillgroup.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case careerskillgroup.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case careerskillgroup.FieldLabel:
		return m.OldLabel(ctx)
	}
	return nil, fmt.Errorf("unknown CareerSkillGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CareerSkillGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case careerskillgroup.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case careerskillgroup.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case careerskillgroup.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	}
	return fmt.Errorf("unknown CareerSkillGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CareerSkillGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CareerSkillGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CareerSkillGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CareerSkillGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CareerSkillGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CareerSkillGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CareerSkillGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CareerSkillGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CareerSkillGroupMutation) ResetField(name string) error {
	switch name {
	case careerskillgroup.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case careerskillgroup.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case careerskillgroup.FieldLabel:
		m.ResetLabel()
		return nil
	}
	return fmt.Errorf("unknown CareerSkillGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CareerSkillGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.career != nil {
		edges = append(edges, careerskillgroup.EdgeCareer)
	}
	if m.careerSkills != nil {
		edges = append(edges, careerskillgroup.EdgeCareerSkills)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CareerSkillGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case careerskillgroup.EdgeCareer:
		if id := m.career; id != nil {
			return []ent.Value{*id}
		}
	case careerskillgroup.EdgeCareerSkills:
		ids := make([]ent.Value, 0, len(m.careerSkills))
		for id := range m.careerSkills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CareerSkillGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcareerSkills != nil {
		edges = append(edges, careerskillgroup.EdgeCareerSkills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CareerSkillGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case careerskillgroup.EdgeCareerSkills:
		ids := make([]ent.Value, 0, len(m.removedcareerSkills))
		for id := range m.removedcareerSkills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CareerSkillGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcareer {
		edges = append(edges, careerskillgroup.EdgeCareer)
	}
	if m.clearedcareerSkills {
		edges = append(edges, careerskillgroup.EdgeCareerSkills)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CareerSkillGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case careerskillgroup.EdgeCareer:
		return m.clearedcareer
	case careerskillgroup.EdgeCareerSkills:
		return m.clearedcareerSkills
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CareerSkillGroupMutation) ClearEdge(name string) error {
	switch name {
	case careerskillgroup.EdgeCareer:
		m.ClearCareer()
		return nil
	}
	return fmt.Errorf("unknown CareerSkillGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CareerSkillGroupMutation) ResetEdge(name string) error {
	switch name {
	case careerskillgroup.EdgeCareer:
		m.ResetCareer()
		return nil
	case careerskillgroup.EdgeCareerSkills:
		m.ResetCareerSkills()
		return nil
	}
	return fmt.Errorf("unknown CareerSkillGroup edge %s", name)
}

// CareerTaskMutation represents an operation that mutates the CareerTask nodes in the graph.
type CareerTaskMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	create_time                   *time.Time
	update_time                   *time.Time
	name                          *string
	clearedFields                 map[string]struct{}
	career                        *int
	clearedcareer                 bool
	careerTaskDescriptions        map[int]struct{}
	removedcareerTaskDescriptions map[int]struct{}
	clearedcareerTaskDescriptions bool
	done                          bool
	oldValue                      func(context.Context) (*CareerTask, error)
	predicates                    []predicate.CareerTask
}

var _ ent.Mutation = (*CareerTaskMutation)(nil)

// careertaskOption allows management of the mutation configuration using functional options.
type careertaskOption func(*CareerTaskMutation)

// newCareerTaskMutation creates new mutation for the CareerTask entity.
func newCareerTaskMutation(c config, op Op, opts ...careertaskOption) *CareerTaskMutation {
	m := &CareerTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeCareerTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCareerTaskID sets the ID field of the mutation.
func withCareerTaskID(id int) careertaskOption {
	return func(m *CareerTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *CareerTask
		)
		m.oldValue = func(ctx context.Context) (*CareerTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CareerTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCareerTask sets the old CareerTask of the mutation.
func withCareerTask(node *CareerTask) careertaskOption {
	return func(m *CareerTaskMutation) {
		m.oldValue = func(context.Context) (*CareerTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CareerTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CareerTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CareerTaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CareerTaskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CareerTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CareerTaskMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CareerTaskMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CareerTask entity.
// If the CareerTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CareerTaskMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CareerTaskMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CareerTaskMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CareerTaskMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CareerTask entity.
// If the CareerTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CareerTaskMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CareerTaskMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *CareerTaskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CareerTaskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CareerTask entity.
// If the CareerTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CareerTaskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CareerTaskMutation) ResetName() {
	m.name = nil
}

// SetCareerID sets the "career" edge to the UserCareer entity by id.
func (m *CareerTaskMutation) SetCareerID(id int) {
	m.career = &id
}

// ClearCareer clears the "career" edge to the UserCareer entity.
func (m *CareerTaskMutation) ClearCareer() {
	m.clearedcareer = true
}

// CareerCleared reports if the "career" edge to the UserCareer entity was cleared.
func (m *CareerTaskMutation) CareerCleared() bool {
	return m.clearedcareer
}

// CareerID returns the "career" edge ID in the mutation.
func (m *CareerTaskMutation) CareerID() (id int, exists bool) {
	if m.career != nil {
		return *m.career, true
	}
	return
}

// CareerIDs returns the "career" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CareerID instead. It exists only for internal usage by the builders.
func (m *CareerTaskMutation) CareerIDs() (ids []int) {
	if id := m.career; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCareer resets all changes to the "career" edge.
func (m *CareerTaskMutation) ResetCareer() {
	m.career = nil
	m.clearedcareer = false
}

// AddCareerTaskDescriptionIDs adds the "careerTaskDescriptions" edge to the CareerTaskDescription entity by ids.
func (m *CareerTaskMutation) AddCareerTaskDescriptionIDs(ids ...int) {
	if m.careerTaskDescriptions == nil {
		m.careerTaskDescriptions = make(map[int]struct{})
	}
	for i := range ids {
		m.careerTaskDescriptions[ids[i]] = struct{}{}
	}
}

// ClearCareerTaskDescriptions clears the "careerTaskDescriptions" edge to the CareerTaskDescription entity.
func (m *CareerTaskMutation) ClearCareerTaskDescriptions() {
	m.clearedcareerTaskDescriptions = true
}

// CareerTaskDescriptionsCleared reports if the "careerTaskDescriptions" edge to the CareerTaskDescription entity was cleared.
func (m *CareerTaskMutation) CareerTaskDescriptionsCleared() bool {
	return m.clearedcareerTaskDescriptions
}

// RemoveCareerTaskDescriptionIDs removes the "careerTaskDescriptions" edge to the CareerTaskDescription entity by IDs.
func (m *CareerTaskMutation) RemoveCareerTaskDescriptionIDs(ids ...int) {
	if m.removedcareerTaskDescriptions == nil {
		m.removedcareerTaskDescriptions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.careerTaskDescriptions, ids[i])
		m.removedcareerTaskDescriptions[ids[i]] = struct{}{}
	}
}

// RemovedCareerTaskDescriptions returns the removed IDs of the "careerTaskDescriptions" edge to the CareerTaskDescription entity.
func (m *CareerTaskMutation) RemovedCareerTaskDescriptionsIDs() (ids []int) {
	for id := range m.removedcareerTaskDescriptions {
		ids = append(ids, id)
	}
	return
}

// CareerTaskDescriptionsIDs returns the "careerTaskDescriptions" edge IDs in the mutation.
func (m *CareerTaskMutation) CareerTaskDescriptionsIDs() (ids []int) {
	for id := range m.careerTaskDescriptions {
		ids = append(ids, id)
	}
	return
}

// ResetCareerTaskDescriptions resets all changes to the "careerTaskDescriptions" edge.
func (m *CareerTaskMutation) ResetCareerTaskDescriptions() {
	m.careerTaskDescriptions = nil
	m.clearedcareerTaskDescriptions = false
	m.removedcareerTaskDescriptions = nil
}

// Where appends a list predicates to the CareerTaskMutation builder.
func (m *CareerTaskMutation) Where(ps ...predicate.CareerTask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CareerTaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CareerTaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CareerTask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CareerTaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CareerTaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CareerTask).
func (m *CareerTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CareerTaskMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, careertask.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, careertask.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, careertask.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CareerTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case careertask.FieldCreateTime:
		return m.CreateTime()
	case careertask.FieldUpdateTime:
		return m.UpdateTime()
	case careertask.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CareerTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case careertask.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case careertask.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case careertask.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown CareerTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CareerTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case careertask.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case careertask.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case careertask.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown CareerTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CareerTaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CareerTaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CareerTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CareerTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CareerTaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CareerTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CareerTaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CareerTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CareerTaskMutation) ResetField(name string) error {
	switch name {
	case careertask.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case careertask.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case careertask.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown CareerTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CareerTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.career != nil {
		edges = append(edges, careertask.EdgeCareer)
	}
	if m.careerTaskDescriptions != nil {
		edges = append(edges, careertask.EdgeCareerTaskDescriptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CareerTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case careertask.EdgeCareer:
		if id := m.career; id != nil {
			return []ent.Value{*id}
		}
	case careertask.EdgeCareerTaskDescriptions:
		ids := make([]ent.Value, 0, len(m.careerTaskDescriptions))
		for id := range m.careerTaskDescriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CareerTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcareerTaskDescriptions != nil {
		edges = append(edges, careertask.EdgeCareerTaskDescriptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CareerTaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case careertask.EdgeCareerTaskDescriptions:
		ids := make([]ent.Value, 0, len(m.removedcareerTaskDescriptions))
		for id := range m.removedcareerTaskDescriptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CareerTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcareer {
		edges = append(edges, careertask.EdgeCareer)
	}
	if m.clearedcareerTaskDescriptions {
		edges = append(edges, careertask.EdgeCareerTaskDescriptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CareerTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case careertask.EdgeCareer:
		return m.clearedcareer
	case careertask.EdgeCareerTaskDescriptions:
		return m.clearedcareerTaskDescriptions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CareerTaskMutation) ClearEdge(name string) error {
	switch name {
	case careertask.EdgeCareer:
		m.ClearCareer()
		return nil
	}
	return fmt.Errorf("unknown CareerTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CareerTaskMutation) ResetEdge(name string) error {
	switch name {
	case careertask.EdgeCareer:
		m.ResetCareer()
		return nil
	case careertask.EdgeCareerTaskDescriptions:
		m.ResetCareerTaskDescriptions()
		return nil
	}
	return fmt.Errorf("unknown CareerTask edge %s", name)
}

// CareerTaskDescriptionMutation represents an operation that mutates the CareerTaskDescription nodes in the graph.
type CareerTaskDescriptionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	description       *string
	clearedFields     map[string]struct{}
	careerTask        *int
	clearedcareerTask bool
	done              bool
	oldValue          func(context.Context) (*CareerTaskDescription, error)
	predicates        []predicate.CareerTaskDescription
}

var _ ent.Mutation = (*CareerTaskDescriptionMutation)(nil)

// careertaskdescriptionOption allows management of the mutation configuration using functional options.
type careertaskdescriptionOption func(*CareerTaskDescriptionMutation)

// newCareerTaskDescriptionMutation creates new mutation for the CareerTaskDescription entity.
func newCareerTaskDescriptionMutation(c config, op Op, opts ...careertaskdescriptionOption) *CareerTaskDescriptionMutation {
	m := &CareerTaskDescriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeCareerTaskDescription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCareerTaskDescriptionID sets the ID field of the mutation.
func withCareerTaskDescriptionID(id int) careertaskdescriptionOption {
	return func(m *CareerTaskDescriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *CareerTaskDescription
		)
		m.oldValue = func(ctx context.Context) (*CareerTaskDescription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CareerTaskDescription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCareerTaskDescription sets the old CareerTaskDescription of the mutation.
func withCareerTaskDescription(node *CareerTaskDescription) careertaskdescriptionOption {
	return func(m *CareerTaskDescriptionMutation) {
		m.oldValue = func(context.Context) (*CareerTaskDescription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CareerTaskDescriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CareerTaskDescriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CareerTaskDescriptionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CareerTaskDescriptionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CareerTaskDescription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *CareerTaskDescriptionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CareerTaskDescriptionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CareerTaskDescription entity.
// If the CareerTaskDescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CareerTaskDescriptionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CareerTaskDescriptionMutation) ResetDescription() {
	m.description = nil
}

// SetCareerTaskID sets the "careerTask" edge to the CareerTask entity by id.
func (m *CareerTaskDescriptionMutation) SetCareerTaskID(id int) {
	m.careerTask = &id
}

// ClearCareerTask clears the "careerTask" edge to the CareerTask entity.
func (m *CareerTaskDescriptionMutation) ClearCareerTask() {
	m.clearedcareerTask = true
}

// CareerTaskCleared reports if the "careerTask" edge to the CareerTask entity was cleared.
func (m *CareerTaskDescriptionMutation) CareerTaskCleared() bool {
	return m.clearedcareerTask
}

// CareerTaskID returns the "careerTask" edge ID in the mutation.
func (m *CareerTaskDescriptionMutation) CareerTaskID() (id int, exists bool) {
	if m.careerTask != nil {
		return *m.careerTask, true
	}
	return
}

// CareerTaskIDs returns the "careerTask" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CareerTaskID instead. It exists only for internal usage by the builders.
func (m *CareerTaskDescriptionMutation) CareerTaskIDs() (ids []int) {
	if id := m.careerTask; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCareerTask resets all changes to the "careerTask" edge.
func (m *CareerTaskDescriptionMutation) ResetCareerTask() {
	m.careerTask = nil
	m.clearedcareerTask = false
}

// Where appends a list predicates to the CareerTaskDescriptionMutation builder.
func (m *CareerTaskDescriptionMutation) Where(ps ...predicate.CareerTaskDescription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CareerTaskDescriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CareerTaskDescriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CareerTaskDescription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CareerTaskDescriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CareerTaskDescriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CareerTaskDescription).
func (m *CareerTaskDescriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CareerTaskDescriptionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.description != nil {
		fields = append(fields, careertaskdescription.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CareerTaskDescriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case careertaskdescription.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CareerTaskDescriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case careertaskdescription.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown CareerTaskDescription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CareerTaskDescriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case careertaskdescription.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown CareerTaskDescription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CareerTaskDescriptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CareerTaskDescriptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CareerTaskDescriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CareerTaskDescription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CareerTaskDescriptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CareerTaskDescriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CareerTaskDescriptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CareerTaskDescription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CareerTaskDescriptionMutation) ResetField(name string) error {
	switch name {
	case careertaskdescription.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown CareerTaskDescription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CareerTaskDescriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.careerTask != nil {
		edges = append(edges, careertaskdescription.EdgeCareerTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CareerTaskDescriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case careertaskdescription.EdgeCareerTask:
		if id := m.careerTask; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CareerTaskDescriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CareerTaskDescriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CareerTaskDescriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcareerTask {
		edges = append(edges, careertaskdescription.EdgeCareerTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CareerTaskDescriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case careertaskdescription.EdgeCareerTask:
		return m.clearedcareerTask
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CareerTaskDescriptionMutation) ClearEdge(name string) error {
	switch name {
	case careertaskdescription.EdgeCareerTask:
		m.ClearCareerTask()
		return nil
	}
	return fmt.Errorf("unknown CareerTaskDescription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CareerTaskDescriptionMutation) ResetEdge(name string) error {
	switch name {
	case careertaskdescription.EdgeCareerTask:
		m.ResetCareerTask()
		return nil
	}
	return fmt.Errorf("unknown CareerTaskDescription edge %s", name)
}

// SkillMutation represents an operation that mutates the Skill nodes in the graph.
type SkillMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	create_time         *time.Time
	update_time         *time.Time
	name                *string
	key                 *string
	url                 *string
	clearedFields       map[string]struct{}
	skillTag            *int
	clearedskillTag     bool
	careerSkills        map[int]struct{}
	removedcareerSkills map[int]struct{}
	clearedcareerSkills bool
	done                bool
	oldValue            func(context.Context) (*Skill, error)
	predicates          []predicate.Skill
}

var _ ent.Mutation = (*SkillMutation)(nil)

// skillOption allows management of the mutation configuration using functional options.
type skillOption func(*SkillMutation)

// newSkillMutation creates new mutation for the Skill entity.
func newSkillMutation(c config, op Op, opts ...skillOption) *SkillMutation {
	m := &SkillMutation{
		config:        c,
		op:            op,
		typ:           TypeSkill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSkillID sets the ID field of the mutation.
func withSkillID(id int) skillOption {
	return func(m *SkillMutation) {
		var (
			err   error
			once  sync.Once
			value *Skill
		)
		m.oldValue = func(ctx context.Context) (*Skill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Skill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSkill sets the old Skill of the mutation.
func withSkill(node *Skill) skillOption {
	return func(m *SkillMutation) {
		m.oldValue = func(context.Context) (*Skill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SkillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SkillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SkillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SkillMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Skill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SkillMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SkillMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SkillMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SkillMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SkillMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SkillMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *SkillMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SkillMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SkillMutation) ResetName() {
	m.name = nil
}

// SetKey sets the "key" field.
func (m *SkillMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SkillMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SkillMutation) ResetKey() {
	m.key = nil
}

// SetURL sets the "url" field.
func (m *SkillMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *SkillMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *SkillMutation) ClearURL() {
	m.url = nil
	m.clearedFields[skill.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *SkillMutation) URLCleared() bool {
	_, ok := m.clearedFields[skill.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *SkillMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, skill.FieldURL)
}

// SetSkillTagID sets the "skillTag" edge to the SkillTag entity by id.
func (m *SkillMutation) SetSkillTagID(id int) {
	m.skillTag = &id
}

// ClearSkillTag clears the "skillTag" edge to the SkillTag entity.
func (m *SkillMutation) ClearSkillTag() {
	m.clearedskillTag = true
}

// SkillTagCleared reports if the "skillTag" edge to the SkillTag entity was cleared.
func (m *SkillMutation) SkillTagCleared() bool {
	return m.clearedskillTag
}

// SkillTagID returns the "skillTag" edge ID in the mutation.
func (m *SkillMutation) SkillTagID() (id int, exists bool) {
	if m.skillTag != nil {
		return *m.skillTag, true
	}
	return
}

// SkillTagIDs returns the "skillTag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SkillTagID instead. It exists only for internal usage by the builders.
func (m *SkillMutation) SkillTagIDs() (ids []int) {
	if id := m.skillTag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSkillTag resets all changes to the "skillTag" edge.
func (m *SkillMutation) ResetSkillTag() {
	m.skillTag = nil
	m.clearedskillTag = false
}

// AddCareerSkillIDs adds the "careerSkills" edge to the CareerSkill entity by ids.
func (m *SkillMutation) AddCareerSkillIDs(ids ...int) {
	if m.careerSkills == nil {
		m.careerSkills = make(map[int]struct{})
	}
	for i := range ids {
		m.careerSkills[ids[i]] = struct{}{}
	}
}

// ClearCareerSkills clears the "careerSkills" edge to the CareerSkill entity.
func (m *SkillMutation) ClearCareerSkills() {
	m.clearedcareerSkills = true
}

// CareerSkillsCleared reports if the "careerSkills" edge to the CareerSkill entity was cleared.
func (m *SkillMutation) CareerSkillsCleared() bool {
	return m.clearedcareerSkills
}

// RemoveCareerSkillIDs removes the "careerSkills" edge to the CareerSkill entity by IDs.
func (m *SkillMutation) RemoveCareerSkillIDs(ids ...int) {
	if m.removedcareerSkills == nil {
		m.removedcareerSkills = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.careerSkills, ids[i])
		m.removedcareerSkills[ids[i]] = struct{}{}
	}
}

// RemovedCareerSkills returns the removed IDs of the "careerSkills" edge to the CareerSkill entity.
func (m *SkillMutation) RemovedCareerSkillsIDs() (ids []int) {
	for id := range m.removedcareerSkills {
		ids = append(ids, id)
	}
	return
}

// CareerSkillsIDs returns the "careerSkills" edge IDs in the mutation.
func (m *SkillMutation) CareerSkillsIDs() (ids []int) {
	for id := range m.careerSkills {
		ids = append(ids, id)
	}
	return
}

// ResetCareerSkills resets all changes to the "careerSkills" edge.
func (m *SkillMutation) ResetCareerSkills() {
	m.careerSkills = nil
	m.clearedcareerSkills = false
	m.removedcareerSkills = nil
}

// Where appends a list predicates to the SkillMutation builder.
func (m *SkillMutation) Where(ps ...predicate.Skill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SkillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SkillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Skill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SkillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SkillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Skill).
func (m *SkillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SkillMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, skill.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, skill.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, skill.FieldName)
	}
	if m.key != nil {
		fields = append(fields, skill.FieldKey)
	}
	if m.url != nil {
		fields = append(fields, skill.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SkillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case skill.FieldCreateTime:
		return m.CreateTime()
	case skill.FieldUpdateTime:
		return m.UpdateTime()
	case skill.FieldName:
		return m.Name()
	case skill.FieldKey:
		return m.Key()
	case skill.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SkillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case skill.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case skill.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case skill.FieldName:
		return m.OldName(ctx)
	case skill.FieldKey:
		return m.OldKey(ctx)
	case skill.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown Skill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case skill.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case skill.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case skill.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case skill.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case skill.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown Skill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SkillMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SkillMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Skill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SkillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(skill.FieldURL) {
		fields = append(fields, skill.FieldURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SkillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SkillMutation) ClearField(name string) error {
	switch name {
	case skill.FieldURL:
		m.ClearURL()
		return nil
	}
	return fmt.Errorf("unknown Skill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SkillMutation) ResetField(name string) error {
	switch name {
	case skill.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case skill.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case skill.FieldName:
		m.ResetName()
		return nil
	case skill.FieldKey:
		m.ResetKey()
		return nil
	case skill.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown Skill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SkillMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.skillTag != nil {
		edges = append(edges, skill.EdgeSkillTag)
	}
	if m.careerSkills != nil {
		edges = append(edges, skill.EdgeCareerSkills)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SkillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case skill.EdgeSkillTag:
		if id := m.skillTag; id != nil {
			return []ent.Value{*id}
		}
	case skill.EdgeCareerSkills:
		ids := make([]ent.Value, 0, len(m.careerSkills))
		for id := range m.careerSkills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SkillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcareerSkills != nil {
		edges = append(edges, skill.EdgeCareerSkills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SkillMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case skill.EdgeCareerSkills:
		ids := make([]ent.Value, 0, len(m.removedcareerSkills))
		for id := range m.removedcareerSkills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SkillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedskillTag {
		edges = append(edges, skill.EdgeSkillTag)
	}
	if m.clearedcareerSkills {
		edges = append(edges, skill.EdgeCareerSkills)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SkillMutation) EdgeCleared(name string) bool {
	switch name {
	case skill.EdgeSkillTag:
		return m.clearedskillTag
	case skill.EdgeCareerSkills:
		return m.clearedcareerSkills
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SkillMutation) ClearEdge(name string) error {
	switch name {
	case skill.EdgeSkillTag:
		m.ClearSkillTag()
		return nil
	}
	return fmt.Errorf("unknown Skill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SkillMutation) ResetEdge(name string) error {
	switch name {
	case skill.EdgeSkillTag:
		m.ResetSkillTag()
		return nil
	case skill.EdgeCareerSkills:
		m.ResetCareerSkills()
		return nil
	}
	return fmt.Errorf("unknown Skill edge %s", name)
}

// SkillTagMutation represents an operation that mutates the SkillTag nodes in the graph.
type SkillTagMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	key           *string
	clearedFields map[string]struct{}
	skills        map[int]struct{}
	removedskills map[int]struct{}
	clearedskills bool
	done          bool
	oldValue      func(context.Context) (*SkillTag, error)
	predicates    []predicate.SkillTag
}

var _ ent.Mutation = (*SkillTagMutation)(nil)

// skilltagOption allows management of the mutation configuration using functional options.
type skilltagOption func(*SkillTagMutation)

// newSkillTagMutation creates new mutation for the SkillTag entity.
func newSkillTagMutation(c config, op Op, opts ...skilltagOption) *SkillTagMutation {
	m := &SkillTagMutation{
		config:        c,
		op:            op,
		typ:           TypeSkillTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSkillTagID sets the ID field of the mutation.
func withSkillTagID(id int) skilltagOption {
	return func(m *SkillTagMutation) {
		var (
			err   error
			once  sync.Once
			value *SkillTag
		)
		m.oldValue = func(ctx context.Context) (*SkillTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SkillTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSkillTag sets the old SkillTag of the mutation.
func withSkillTag(node *SkillTag) skilltagOption {
	return func(m *SkillTagMutation) {
		m.oldValue = func(context.Context) (*SkillTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SkillTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SkillTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SkillTagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SkillTagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SkillTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SkillTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SkillTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SkillTag entity.
// If the SkillTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SkillTagMutation) ResetName() {
	m.name = nil
}

// SetKey sets the "key" field.
func (m *SkillTagMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SkillTagMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the SkillTag entity.
// If the SkillTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillTagMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SkillTagMutation) ResetKey() {
	m.key = nil
}

// AddSkillIDs adds the "skills" edge to the Skill entity by ids.
func (m *SkillTagMutation) AddSkillIDs(ids ...int) {
	if m.skills == nil {
		m.skills = make(map[int]struct{})
	}
	for i := range ids {
		m.skills[ids[i]] = struct{}{}
	}
}

// ClearSkills clears the "skills" edge to the Skill entity.
func (m *SkillTagMutation) ClearSkills() {
	m.clearedskills = true
}

// SkillsCleared reports if the "skills" edge to the Skill entity was cleared.
func (m *SkillTagMutation) SkillsCleared() bool {
	return m.clearedskills
}

// RemoveSkillIDs removes the "skills" edge to the Skill entity by IDs.
func (m *SkillTagMutation) RemoveSkillIDs(ids ...int) {
	if m.removedskills == nil {
		m.removedskills = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.skills, ids[i])
		m.removedskills[ids[i]] = struct{}{}
	}
}

// RemovedSkills returns the removed IDs of the "skills" edge to the Skill entity.
func (m *SkillTagMutation) RemovedSkillsIDs() (ids []int) {
	for id := range m.removedskills {
		ids = append(ids, id)
	}
	return
}

// SkillsIDs returns the "skills" edge IDs in the mutation.
func (m *SkillTagMutation) SkillsIDs() (ids []int) {
	for id := range m.skills {
		ids = append(ids, id)
	}
	return
}

// ResetSkills resets all changes to the "skills" edge.
func (m *SkillTagMutation) ResetSkills() {
	m.skills = nil
	m.clearedskills = false
	m.removedskills = nil
}

// Where appends a list predicates to the SkillTagMutation builder.
func (m *SkillTagMutation) Where(ps ...predicate.SkillTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SkillTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SkillTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SkillTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SkillTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SkillTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SkillTag).
func (m *SkillTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SkillTagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, skilltag.FieldName)
	}
	if m.key != nil {
		fields = append(fields, skilltag.FieldKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SkillTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case skilltag.FieldName:
		return m.Name()
	case skilltag.FieldKey:
		return m.Key()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SkillTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case skilltag.FieldName:
		return m.OldName(ctx)
	case skilltag.FieldKey:
		return m.OldKey(ctx)
	}
	return nil, fmt.Errorf("unknown SkillTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case skilltag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case skilltag.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	}
	return fmt.Errorf("unknown SkillTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SkillTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SkillTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SkillTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SkillTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SkillTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SkillTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SkillTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SkillTagMutation) ResetField(name string) error {
	switch name {
	case skilltag.FieldName:
		m.ResetName()
		return nil
	case skilltag.FieldKey:
		m.ResetKey()
		return nil
	}
	return fmt.Errorf("unknown SkillTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SkillTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.skills != nil {
		edges = append(edges, skilltag.EdgeSkills)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SkillTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case skilltag.EdgeSkills:
		ids := make([]ent.Value, 0, len(m.skills))
		for id := range m.skills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SkillTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedskills != nil {
		edges = append(edges, skilltag.EdgeSkills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SkillTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case skilltag.EdgeSkills:
		ids := make([]ent.Value, 0, len(m.removedskills))
		for id := range m.removedskills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SkillTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedskills {
		edges = append(edges, skilltag.EdgeSkills)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SkillTagMutation) EdgeCleared(name string) bool {
	switch name {
	case skilltag.EdgeSkills:
		return m.clearedskills
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SkillTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SkillTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SkillTagMutation) ResetEdge(name string) error {
	switch name {
	case skilltag.EdgeSkills:
		m.ResetSkills()
		return nil
	}
	return fmt.Errorf("unknown SkillTag edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	create_time           *time.Time
	update_time           *time.Time
	name                  *string
	nickname              *string
	avatar_url            *string
	birthday_year         *int
	addbirthday_year      *int
	birthday_month        *int
	addbirthday_month     *int
	birthday_day          *int
	addbirthday_day       *int
	job                   *string
	belong_to             *string
	pr                    *string
	clearedFields         map[string]struct{}
	activities            map[int]struct{}
	removedactivities     map[int]struct{}
	clearedactivities     bool
	qualifications        map[int]struct{}
	removedqualifications map[int]struct{}
	clearedqualifications bool
	careerGroups          map[int]struct{}
	removedcareerGroups   map[int]struct{}
	clearedcareerGroups   bool
	notes                 map[int]struct{}
	removednotes          map[int]struct{}
	clearednotes          bool
	done                  bool
	oldValue              func(context.Context) (*User, error)
	predicates            []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetNickname sets the "nickname" field.
func (m *UserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickname(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *UserMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[user.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *UserMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[user.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, user.FieldNickname)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// SetBirthdayYear sets the "birthday_year" field.
func (m *UserMutation) SetBirthdayYear(i int) {
	m.birthday_year = &i
	m.addbirthday_year = nil
}

// BirthdayYear returns the value of the "birthday_year" field in the mutation.
func (m *UserMutation) BirthdayYear() (r int, exists bool) {
	v := m.birthday_year
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthdayYear returns the old "birthday_year" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthdayYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthdayYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthdayYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthdayYear: %w", err)
	}
	return oldValue.BirthdayYear, nil
}

// AddBirthdayYear adds i to the "birthday_year" field.
func (m *UserMutation) AddBirthdayYear(i int) {
	if m.addbirthday_year != nil {
		*m.addbirthday_year += i
	} else {
		m.addbirthday_year = &i
	}
}

// AddedBirthdayYear returns the value that was added to the "birthday_year" field in this mutation.
func (m *UserMutation) AddedBirthdayYear() (r int, exists bool) {
	v := m.addbirthday_year
	if v == nil {
		return
	}
	return *v, true
}

// ResetBirthdayYear resets all changes to the "birthday_year" field.
func (m *UserMutation) ResetBirthdayYear() {
	m.birthday_year = nil
	m.addbirthday_year = nil
}

// SetBirthdayMonth sets the "birthday_month" field.
func (m *UserMutation) SetBirthdayMonth(i int) {
	m.birthday_month = &i
	m.addbirthday_month = nil
}

// BirthdayMonth returns the value of the "birthday_month" field in the mutation.
func (m *UserMutation) BirthdayMonth() (r int, exists bool) {
	v := m.birthday_month
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthdayMonth returns the old "birthday_month" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthdayMonth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthdayMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthdayMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthdayMonth: %w", err)
	}
	return oldValue.BirthdayMonth, nil
}

// AddBirthdayMonth adds i to the "birthday_month" field.
func (m *UserMutation) AddBirthdayMonth(i int) {
	if m.addbirthday_month != nil {
		*m.addbirthday_month += i
	} else {
		m.addbirthday_month = &i
	}
}

// AddedBirthdayMonth returns the value that was added to the "birthday_month" field in this mutation.
func (m *UserMutation) AddedBirthdayMonth() (r int, exists bool) {
	v := m.addbirthday_month
	if v == nil {
		return
	}
	return *v, true
}

// ResetBirthdayMonth resets all changes to the "birthday_month" field.
func (m *UserMutation) ResetBirthdayMonth() {
	m.birthday_month = nil
	m.addbirthday_month = nil
}

// SetBirthdayDay sets the "birthday_day" field.
func (m *UserMutation) SetBirthdayDay(i int) {
	m.birthday_day = &i
	m.addbirthday_day = nil
}

// BirthdayDay returns the value of the "birthday_day" field in the mutation.
func (m *UserMutation) BirthdayDay() (r int, exists bool) {
	v := m.birthday_day
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthdayDay returns the old "birthday_day" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthdayDay(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthdayDay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthdayDay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthdayDay: %w", err)
	}
	return oldValue.BirthdayDay, nil
}

// AddBirthdayDay adds i to the "birthday_day" field.
func (m *UserMutation) AddBirthdayDay(i int) {
	if m.addbirthday_day != nil {
		*m.addbirthday_day += i
	} else {
		m.addbirthday_day = &i
	}
}

// AddedBirthdayDay returns the value that was added to the "birthday_day" field in this mutation.
func (m *UserMutation) AddedBirthdayDay() (r int, exists bool) {
	v := m.addbirthday_day
	if v == nil {
		return
	}
	return *v, true
}

// ResetBirthdayDay resets all changes to the "birthday_day" field.
func (m *UserMutation) ResetBirthdayDay() {
	m.birthday_day = nil
	m.addbirthday_day = nil
}

// SetJob sets the "job" field.
func (m *UserMutation) SetJob(s string) {
	m.job = &s
}

// Job returns the value of the "job" field in the mutation.
func (m *UserMutation) Job() (r string, exists bool) {
	v := m.job
	if v == nil {
		return
	}
	return *v, true
}

// OldJob returns the old "job" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldJob(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJob is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJob requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJob: %w", err)
	}
	return oldValue.Job, nil
}

// ClearJob clears the value of the "job" field.
func (m *UserMutation) ClearJob() {
	m.job = nil
	m.clearedFields[user.FieldJob] = struct{}{}
}

// JobCleared returns if the "job" field was cleared in this mutation.
func (m *UserMutation) JobCleared() bool {
	_, ok := m.clearedFields[user.FieldJob]
	return ok
}

// ResetJob resets all changes to the "job" field.
func (m *UserMutation) ResetJob() {
	m.job = nil
	delete(m.clearedFields, user.FieldJob)
}

// SetBelongTo sets the "belong_to" field.
func (m *UserMutation) SetBelongTo(s string) {
	m.belong_to = &s
}

// BelongTo returns the value of the "belong_to" field in the mutation.
func (m *UserMutation) BelongTo() (r string, exists bool) {
	v := m.belong_to
	if v == nil {
		return
	}
	return *v, true
}

// OldBelongTo returns the old "belong_to" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBelongTo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBelongTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBelongTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBelongTo: %w", err)
	}
	return oldValue.BelongTo, nil
}

// ClearBelongTo clears the value of the "belong_to" field.
func (m *UserMutation) ClearBelongTo() {
	m.belong_to = nil
	m.clearedFields[user.FieldBelongTo] = struct{}{}
}

// BelongToCleared returns if the "belong_to" field was cleared in this mutation.
func (m *UserMutation) BelongToCleared() bool {
	_, ok := m.clearedFields[user.FieldBelongTo]
	return ok
}

// ResetBelongTo resets all changes to the "belong_to" field.
func (m *UserMutation) ResetBelongTo() {
	m.belong_to = nil
	delete(m.clearedFields, user.FieldBelongTo)
}

// SetPr sets the "pr" field.
func (m *UserMutation) SetPr(s string) {
	m.pr = &s
}

// Pr returns the value of the "pr" field in the mutation.
func (m *UserMutation) Pr() (r string, exists bool) {
	v := m.pr
	if v == nil {
		return
	}
	return *v, true
}

// OldPr returns the old "pr" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPr(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPr: %w", err)
	}
	return oldValue.Pr, nil
}

// ClearPr clears the value of the "pr" field.
func (m *UserMutation) ClearPr() {
	m.pr = nil
	m.clearedFields[user.FieldPr] = struct{}{}
}

// PrCleared returns if the "pr" field was cleared in this mutation.
func (m *UserMutation) PrCleared() bool {
	_, ok := m.clearedFields[user.FieldPr]
	return ok
}

// ResetPr resets all changes to the "pr" field.
func (m *UserMutation) ResetPr() {
	m.pr = nil
	delete(m.clearedFields, user.FieldPr)
}

// AddActivityIDs adds the "activities" edge to the UserActivity entity by ids.
func (m *UserMutation) AddActivityIDs(ids ...int) {
	if m.activities == nil {
		m.activities = make(map[int]struct{})
	}
	for i := range ids {
		m.activities[ids[i]] = struct{}{}
	}
}

// ClearActivities clears the "activities" edge to the UserActivity entity.
func (m *UserMutation) ClearActivities() {
	m.clearedactivities = true
}

// ActivitiesCleared reports if the "activities" edge to the UserActivity entity was cleared.
func (m *UserMutation) ActivitiesCleared() bool {
	return m.clearedactivities
}

// RemoveActivityIDs removes the "activities" edge to the UserActivity entity by IDs.
func (m *UserMutation) RemoveActivityIDs(ids ...int) {
	if m.removedactivities == nil {
		m.removedactivities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.activities, ids[i])
		m.removedactivities[ids[i]] = struct{}{}
	}
}

// RemovedActivities returns the removed IDs of the "activities" edge to the UserActivity entity.
func (m *UserMutation) RemovedActivitiesIDs() (ids []int) {
	for id := range m.removedactivities {
		ids = append(ids, id)
	}
	return
}

// ActivitiesIDs returns the "activities" edge IDs in the mutation.
func (m *UserMutation) ActivitiesIDs() (ids []int) {
	for id := range m.activities {
		ids = append(ids, id)
	}
	return
}

// ResetActivities resets all changes to the "activities" edge.
func (m *UserMutation) ResetActivities() {
	m.activities = nil
	m.clearedactivities = false
	m.removedactivities = nil
}

// AddQualificationIDs adds the "qualifications" edge to the UserQualification entity by ids.
func (m *UserMutation) AddQualificationIDs(ids ...int) {
	if m.qualifications == nil {
		m.qualifications = make(map[int]struct{})
	}
	for i := range ids {
		m.qualifications[ids[i]] = struct{}{}
	}
}

// ClearQualifications clears the "qualifications" edge to the UserQualification entity.
func (m *UserMutation) ClearQualifications() {
	m.clearedqualifications = true
}

// QualificationsCleared reports if the "qualifications" edge to the UserQualification entity was cleared.
func (m *UserMutation) QualificationsCleared() bool {
	return m.clearedqualifications
}

// RemoveQualificationIDs removes the "qualifications" edge to the UserQualification entity by IDs.
func (m *UserMutation) RemoveQualificationIDs(ids ...int) {
	if m.removedqualifications == nil {
		m.removedqualifications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.qualifications, ids[i])
		m.removedqualifications[ids[i]] = struct{}{}
	}
}

// RemovedQualifications returns the removed IDs of the "qualifications" edge to the UserQualification entity.
func (m *UserMutation) RemovedQualificationsIDs() (ids []int) {
	for id := range m.removedqualifications {
		ids = append(ids, id)
	}
	return
}

// QualificationsIDs returns the "qualifications" edge IDs in the mutation.
func (m *UserMutation) QualificationsIDs() (ids []int) {
	for id := range m.qualifications {
		ids = append(ids, id)
	}
	return
}

// ResetQualifications resets all changes to the "qualifications" edge.
func (m *UserMutation) ResetQualifications() {
	m.qualifications = nil
	m.clearedqualifications = false
	m.removedqualifications = nil
}

// AddCareerGroupIDs adds the "careerGroups" edge to the UserCareerGroup entity by ids.
func (m *UserMutation) AddCareerGroupIDs(ids ...int) {
	if m.careerGroups == nil {
		m.careerGroups = make(map[int]struct{})
	}
	for i := range ids {
		m.careerGroups[ids[i]] = struct{}{}
	}
}

// ClearCareerGroups clears the "careerGroups" edge to the UserCareerGroup entity.
func (m *UserMutation) ClearCareerGroups() {
	m.clearedcareerGroups = true
}

// CareerGroupsCleared reports if the "careerGroups" edge to the UserCareerGroup entity was cleared.
func (m *UserMutation) CareerGroupsCleared() bool {
	return m.clearedcareerGroups
}

// RemoveCareerGroupIDs removes the "careerGroups" edge to the UserCareerGroup entity by IDs.
func (m *UserMutation) RemoveCareerGroupIDs(ids ...int) {
	if m.removedcareerGroups == nil {
		m.removedcareerGroups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.careerGroups, ids[i])
		m.removedcareerGroups[ids[i]] = struct{}{}
	}
}

// RemovedCareerGroups returns the removed IDs of the "careerGroups" edge to the UserCareerGroup entity.
func (m *UserMutation) RemovedCareerGroupsIDs() (ids []int) {
	for id := range m.removedcareerGroups {
		ids = append(ids, id)
	}
	return
}

// CareerGroupsIDs returns the "careerGroups" edge IDs in the mutation.
func (m *UserMutation) CareerGroupsIDs() (ids []int) {
	for id := range m.careerGroups {
		ids = append(ids, id)
	}
	return
}

// ResetCareerGroups resets all changes to the "careerGroups" edge.
func (m *UserMutation) ResetCareerGroups() {
	m.careerGroups = nil
	m.clearedcareerGroups = false
	m.removedcareerGroups = nil
}

// AddNoteIDs adds the "notes" edge to the UserNote entity by ids.
func (m *UserMutation) AddNoteIDs(ids ...int) {
	if m.notes == nil {
		m.notes = make(map[int]struct{})
	}
	for i := range ids {
		m.notes[ids[i]] = struct{}{}
	}
}

// ClearNotes clears the "notes" edge to the UserNote entity.
func (m *UserMutation) ClearNotes() {
	m.clearednotes = true
}

// NotesCleared reports if the "notes" edge to the UserNote entity was cleared.
func (m *UserMutation) NotesCleared() bool {
	return m.clearednotes
}

// RemoveNoteIDs removes the "notes" edge to the UserNote entity by IDs.
func (m *UserMutation) RemoveNoteIDs(ids ...int) {
	if m.removednotes == nil {
		m.removednotes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notes, ids[i])
		m.removednotes[ids[i]] = struct{}{}
	}
}

// RemovedNotes returns the removed IDs of the "notes" edge to the UserNote entity.
func (m *UserMutation) RemovedNotesIDs() (ids []int) {
	for id := range m.removednotes {
		ids = append(ids, id)
	}
	return
}

// NotesIDs returns the "notes" edge IDs in the mutation.
func (m *UserMutation) NotesIDs() (ids []int) {
	for id := range m.notes {
		ids = append(ids, id)
	}
	return
}

// ResetNotes resets all changes to the "notes" edge.
func (m *UserMutation) ResetNotes() {
	m.notes = nil
	m.clearednotes = false
	m.removednotes = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.nickname != nil {
		fields = append(fields, user.FieldNickname)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.birthday_year != nil {
		fields = append(fields, user.FieldBirthdayYear)
	}
	if m.birthday_month != nil {
		fields = append(fields, user.FieldBirthdayMonth)
	}
	if m.birthday_day != nil {
		fields = append(fields, user.FieldBirthdayDay)
	}
	if m.job != nil {
		fields = append(fields, user.FieldJob)
	}
	if m.belong_to != nil {
		fields = append(fields, user.FieldBelongTo)
	}
	if m.pr != nil {
		fields = append(fields, user.FieldPr)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldName:
		return m.Name()
	case user.FieldNickname:
		return m.Nickname()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldBirthdayYear:
		return m.BirthdayYear()
	case user.FieldBirthdayMonth:
		return m.BirthdayMonth()
	case user.FieldBirthdayDay:
		return m.BirthdayDay()
	case user.FieldJob:
		return m.Job()
	case user.FieldBelongTo:
		return m.BelongTo()
	case user.FieldPr:
		return m.Pr()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldNickname:
		return m.OldNickname(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldBirthdayYear:
		return m.OldBirthdayYear(ctx)
	case user.FieldBirthdayMonth:
		return m.OldBirthdayMonth(ctx)
	case user.FieldBirthdayDay:
		return m.OldBirthdayDay(ctx)
	case user.FieldJob:
		return m.OldJob(ctx)
	case user.FieldBelongTo:
		return m.OldBelongTo(ctx)
	case user.FieldPr:
		return m.OldPr(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldBirthdayYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthdayYear(v)
		return nil
	case user.FieldBirthdayMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthdayMonth(v)
		return nil
	case user.FieldBirthdayDay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthdayDay(v)
		return nil
	case user.FieldJob:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJob(v)
		return nil
	case user.FieldBelongTo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBelongTo(v)
		return nil
	case user.FieldPr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPr(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addbirthday_year != nil {
		fields = append(fields, user.FieldBirthdayYear)
	}
	if m.addbirthday_month != nil {
		fields = append(fields, user.FieldBirthdayMonth)
	}
	if m.addbirthday_day != nil {
		fields = append(fields, user.FieldBirthdayDay)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldBirthdayYear:
		return m.AddedBirthdayYear()
	case user.FieldBirthdayMonth:
		return m.AddedBirthdayMonth()
	case user.FieldBirthdayDay:
		return m.AddedBirthdayDay()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldBirthdayYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBirthdayYear(v)
		return nil
	case user.FieldBirthdayMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBirthdayMonth(v)
		return nil
	case user.FieldBirthdayDay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBirthdayDay(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldNickname) {
		fields = append(fields, user.FieldNickname)
	}
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.FieldCleared(user.FieldJob) {
		fields = append(fields, user.FieldJob)
	}
	if m.FieldCleared(user.FieldBelongTo) {
		fields = append(fields, user.FieldBelongTo)
	}
	if m.FieldCleared(user.FieldPr) {
		fields = append(fields, user.FieldPr)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldNickname:
		m.ClearNickname()
		return nil
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case user.FieldJob:
		m.ClearJob()
		return nil
	case user.FieldBelongTo:
		m.ClearBelongTo()
		return nil
	case user.FieldPr:
		m.ClearPr()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldNickname:
		m.ResetNickname()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldBirthdayYear:
		m.ResetBirthdayYear()
		return nil
	case user.FieldBirthdayMonth:
		m.ResetBirthdayMonth()
		return nil
	case user.FieldBirthdayDay:
		m.ResetBirthdayDay()
		return nil
	case user.FieldJob:
		m.ResetJob()
		return nil
	case user.FieldBelongTo:
		m.ResetBelongTo()
		return nil
	case user.FieldPr:
		m.ResetPr()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.activities != nil {
		edges = append(edges, user.EdgeActivities)
	}
	if m.qualifications != nil {
		edges = append(edges, user.EdgeQualifications)
	}
	if m.careerGroups != nil {
		edges = append(edges, user.EdgeCareerGroups)
	}
	if m.notes != nil {
		edges = append(edges, user.EdgeNotes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.activities))
		for id := range m.activities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeQualifications:
		ids := make([]ent.Value, 0, len(m.qualifications))
		for id := range m.qualifications {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCareerGroups:
		ids := make([]ent.Value, 0, len(m.careerGroups))
		for id := range m.careerGroups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotes:
		ids := make([]ent.Value, 0, len(m.notes))
		for id := range m.notes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedactivities != nil {
		edges = append(edges, user.EdgeActivities)
	}
	if m.removedqualifications != nil {
		edges = append(edges, user.EdgeQualifications)
	}
	if m.removedcareerGroups != nil {
		edges = append(edges, user.EdgeCareerGroups)
	}
	if m.removednotes != nil {
		edges = append(edges, user.EdgeNotes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.removedactivities))
		for id := range m.removedactivities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeQualifications:
		ids := make([]ent.Value, 0, len(m.removedqualifications))
		for id := range m.removedqualifications {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCareerGroups:
		ids := make([]ent.Value, 0, len(m.removedcareerGroups))
		for id := range m.removedcareerGroups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotes:
		ids := make([]ent.Value, 0, len(m.removednotes))
		for id := range m.removednotes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedactivities {
		edges = append(edges, user.EdgeActivities)
	}
	if m.clearedqualifications {
		edges = append(edges, user.EdgeQualifications)
	}
	if m.clearedcareerGroups {
		edges = append(edges, user.EdgeCareerGroups)
	}
	if m.clearednotes {
		edges = append(edges, user.EdgeNotes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeActivities:
		return m.clearedactivities
	case user.EdgeQualifications:
		return m.clearedqualifications
	case user.EdgeCareerGroups:
		return m.clearedcareerGroups
	case user.EdgeNotes:
		return m.clearednotes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeActivities:
		m.ResetActivities()
		return nil
	case user.EdgeQualifications:
		m.ResetQualifications()
		return nil
	case user.EdgeCareerGroups:
		m.ResetCareerGroups()
		return nil
	case user.EdgeNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserActivityMutation represents an operation that mutates the UserActivity nodes in the graph.
type UserActivityMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	name          *string
	url           *string
	icon          *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserActivity, error)
	predicates    []predicate.UserActivity
}

var _ ent.Mutation = (*UserActivityMutation)(nil)

// useractivityOption allows management of the mutation configuration using functional options.
type useractivityOption func(*UserActivityMutation)

// newUserActivityMutation creates new mutation for the UserActivity entity.
func newUserActivityMutation(c config, op Op, opts ...useractivityOption) *UserActivityMutation {
	m := &UserActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeUserActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserActivityID sets the ID field of the mutation.
func withUserActivityID(id int) useractivityOption {
	return func(m *UserActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *UserActivity
		)
		m.oldValue = func(ctx context.Context) (*UserActivity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserActivity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserActivity sets the old UserActivity of the mutation.
func withUserActivity(node *UserActivity) useractivityOption {
	return func(m *UserActivityMutation) {
		m.oldValue = func(context.Context) (*UserActivity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserActivityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserActivityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserActivity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserActivityMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserActivityMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserActivity entity.
// If the UserActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserActivityMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserActivityMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserActivityMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserActivityMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserActivity entity.
// If the UserActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserActivityMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserActivityMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *UserActivityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserActivityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UserActivity entity.
// If the UserActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserActivityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserActivityMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *UserActivityMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *UserActivityMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the UserActivity entity.
// If the UserActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserActivityMutation) OldURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *UserActivityMutation) ClearURL() {
	m.url = nil
	m.clearedFields[useractivity.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *UserActivityMutation) URLCleared() bool {
	_, ok := m.clearedFields[useractivity.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *UserActivityMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, useractivity.FieldURL)
}

// SetIcon sets the "icon" field.
func (m *UserActivityMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *UserActivityMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the UserActivity entity.
// If the UserActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserActivityMutation) OldIcon(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *UserActivityMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[useractivity.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *UserActivityMutation) IconCleared() bool {
	_, ok := m.clearedFields[useractivity.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *UserActivityMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, useractivity.FieldIcon)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserActivityMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserActivityMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserActivityMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserActivityMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserActivityMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserActivityMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserActivityMutation builder.
func (m *UserActivityMutation) Where(ps ...predicate.UserActivity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserActivityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserActivityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserActivity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserActivityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserActivityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserActivity).
func (m *UserActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserActivityMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, useractivity.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, useractivity.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, useractivity.FieldName)
	}
	if m.url != nil {
		fields = append(fields, useractivity.FieldURL)
	}
	if m.icon != nil {
		fields = append(fields, useractivity.FieldIcon)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useractivity.FieldCreateTime:
		return m.CreateTime()
	case useractivity.FieldUpdateTime:
		return m.UpdateTime()
	case useractivity.FieldName:
		return m.Name()
	case useractivity.FieldURL:
		return m.URL()
	case useractivity.FieldIcon:
		return m.Icon()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useractivity.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case useractivity.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case useractivity.FieldName:
		return m.OldName(ctx)
	case useractivity.FieldURL:
		return m.OldURL(ctx)
	case useractivity.FieldIcon:
		return m.OldIcon(ctx)
	}
	return nil, fmt.Errorf("unknown UserActivity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useractivity.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case useractivity.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case useractivity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case useractivity.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case useractivity.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	}
	return fmt.Errorf("unknown UserActivity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserActivityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserActivityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserActivity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserActivityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(useractivity.FieldURL) {
		fields = append(fields, useractivity.FieldURL)
	}
	if m.FieldCleared(useractivity.FieldIcon) {
		fields = append(fields, useractivity.FieldIcon)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserActivityMutation) ClearField(name string) error {
	switch name {
	case useractivity.FieldURL:
		m.ClearURL()
		return nil
	case useractivity.FieldIcon:
		m.ClearIcon()
		return nil
	}
	return fmt.Errorf("unknown UserActivity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserActivityMutation) ResetField(name string) error {
	switch name {
	case useractivity.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case useractivity.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case useractivity.FieldName:
		m.ResetName()
		return nil
	case useractivity.FieldURL:
		m.ResetURL()
		return nil
	case useractivity.FieldIcon:
		m.ResetIcon()
		return nil
	}
	return fmt.Errorf("unknown UserActivity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, useractivity.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case useractivity.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserActivityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, useractivity.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case useractivity.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserActivityMutation) ClearEdge(name string) error {
	switch name {
	case useractivity.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserActivity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserActivityMutation) ResetEdge(name string) error {
	switch name {
	case useractivity.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserActivity edge %s", name)
}

// UserCareerMutation represents an operation that mutates the UserCareer nodes in the graph.
type UserCareerMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	create_time               *time.Time
	update_time               *time.Time
	name                      *string
	from                      *string
	to                        *string
	clearedFields             map[string]struct{}
	careerGroup               *int
	clearedcareerGroup        bool
	careerDescriptions        map[int]struct{}
	removedcareerDescriptions map[int]struct{}
	clearedcareerDescriptions bool
	careerTasks               map[int]struct{}
	removedcareerTasks        map[int]struct{}
	clearedcareerTasks        bool
	careerSkillGroups         map[int]struct{}
	removedcareerSkillGroups  map[int]struct{}
	clearedcareerSkillGroups  bool
	done                      bool
	oldValue                  func(context.Context) (*UserCareer, error)
	predicates                []predicate.UserCareer
}

var _ ent.Mutation = (*UserCareerMutation)(nil)

// usercareerOption allows management of the mutation configuration using functional options.
type usercareerOption func(*UserCareerMutation)

// newUserCareerMutation creates new mutation for the UserCareer entity.
func newUserCareerMutation(c config, op Op, opts ...usercareerOption) *UserCareerMutation {
	m := &UserCareerMutation{
		config:        c,
		op:            op,
		typ:           TypeUserCareer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserCareerID sets the ID field of the mutation.
func withUserCareerID(id int) usercareerOption {
	return func(m *UserCareerMutation) {
		var (
			err   error
			once  sync.Once
			value *UserCareer
		)
		m.oldValue = func(ctx context.Context) (*UserCareer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserCareer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserCareer sets the old UserCareer of the mutation.
func withUserCareer(node *UserCareer) usercareerOption {
	return func(m *UserCareerMutation) {
		m.oldValue = func(context.Context) (*UserCareer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserCareerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserCareerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserCareerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserCareerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserCareer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserCareerMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserCareerMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserCareer entity.
// If the UserCareer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCareerMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserCareerMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserCareerMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserCareerMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserCareer entity.
// If the UserCareer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCareerMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserCareerMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *UserCareerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserCareerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UserCareer entity.
// If the UserCareer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCareerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserCareerMutation) ResetName() {
	m.name = nil
}

// SetFrom sets the "from" field.
func (m *UserCareerMutation) SetFrom(s string) {
	m.from = &s
}

// From returns the value of the "from" field in the mutation.
func (m *UserCareerMutation) From() (r string, exists bool) {
	v := m.from
	if v == nil {
		return
	}
	return *v, true
}

// OldFrom returns the old "from" field's value of the UserCareer entity.
// If the UserCareer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCareerMutation) OldFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrom: %w", err)
	}
	return oldValue.From, nil
}

// ResetFrom resets all changes to the "from" field.
func (m *UserCareerMutation) ResetFrom() {
	m.from = nil
}

// SetTo sets the "to" field.
func (m *UserCareerMutation) SetTo(s string) {
	m.to = &s
}

// To returns the value of the "to" field in the mutation.
func (m *UserCareerMutation) To() (r string, exists bool) {
	v := m.to
	if v == nil {
		return
	}
	return *v, true
}

// OldTo returns the old "to" field's value of the UserCareer entity.
// If the UserCareer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCareerMutation) OldTo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTo: %w", err)
	}
	return oldValue.To, nil
}

// ClearTo clears the value of the "to" field.
func (m *UserCareerMutation) ClearTo() {
	m.to = nil
	m.clearedFields[usercareer.FieldTo] = struct{}{}
}

// ToCleared returns if the "to" field was cleared in this mutation.
func (m *UserCareerMutation) ToCleared() bool {
	_, ok := m.clearedFields[usercareer.FieldTo]
	return ok
}

// ResetTo resets all changes to the "to" field.
func (m *UserCareerMutation) ResetTo() {
	m.to = nil
	delete(m.clearedFields, usercareer.FieldTo)
}

// SetCareerGroupID sets the "careerGroup" edge to the UserCareerGroup entity by id.
func (m *UserCareerMutation) SetCareerGroupID(id int) {
	m.careerGroup = &id
}

// ClearCareerGroup clears the "careerGroup" edge to the UserCareerGroup entity.
func (m *UserCareerMutation) ClearCareerGroup() {
	m.clearedcareerGroup = true
}

// CareerGroupCleared reports if the "careerGroup" edge to the UserCareerGroup entity was cleared.
func (m *UserCareerMutation) CareerGroupCleared() bool {
	return m.clearedcareerGroup
}

// CareerGroupID returns the "careerGroup" edge ID in the mutation.
func (m *UserCareerMutation) CareerGroupID() (id int, exists bool) {
	if m.careerGroup != nil {
		return *m.careerGroup, true
	}
	return
}

// CareerGroupIDs returns the "careerGroup" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CareerGroupID instead. It exists only for internal usage by the builders.
func (m *UserCareerMutation) CareerGroupIDs() (ids []int) {
	if id := m.careerGroup; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCareerGroup resets all changes to the "careerGroup" edge.
func (m *UserCareerMutation) ResetCareerGroup() {
	m.careerGroup = nil
	m.clearedcareerGroup = false
}

// AddCareerDescriptionIDs adds the "careerDescriptions" edge to the UserCareerDescription entity by ids.
func (m *UserCareerMutation) AddCareerDescriptionIDs(ids ...int) {
	if m.careerDescriptions == nil {
		m.careerDescriptions = make(map[int]struct{})
	}
	for i := range ids {
		m.careerDescriptions[ids[i]] = struct{}{}
	}
}

// ClearCareerDescriptions clears the "careerDescriptions" edge to the UserCareerDescription entity.
func (m *UserCareerMutation) ClearCareerDescriptions() {
	m.clearedcareerDescriptions = true
}

// CareerDescriptionsCleared reports if the "careerDescriptions" edge to the UserCareerDescription entity was cleared.
func (m *UserCareerMutation) CareerDescriptionsCleared() bool {
	return m.clearedcareerDescriptions
}

// RemoveCareerDescriptionIDs removes the "careerDescriptions" edge to the UserCareerDescription entity by IDs.
func (m *UserCareerMutation) RemoveCareerDescriptionIDs(ids ...int) {
	if m.removedcareerDescriptions == nil {
		m.removedcareerDescriptions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.careerDescriptions, ids[i])
		m.removedcareerDescriptions[ids[i]] = struct{}{}
	}
}

// RemovedCareerDescriptions returns the removed IDs of the "careerDescriptions" edge to the UserCareerDescription entity.
func (m *UserCareerMutation) RemovedCareerDescriptionsIDs() (ids []int) {
	for id := range m.removedcareerDescriptions {
		ids = append(ids, id)
	}
	return
}

// CareerDescriptionsIDs returns the "careerDescriptions" edge IDs in the mutation.
func (m *UserCareerMutation) CareerDescriptionsIDs() (ids []int) {
	for id := range m.careerDescriptions {
		ids = append(ids, id)
	}
	return
}

// ResetCareerDescriptions resets all changes to the "careerDescriptions" edge.
func (m *UserCareerMutation) ResetCareerDescriptions() {
	m.careerDescriptions = nil
	m.clearedcareerDescriptions = false
	m.removedcareerDescriptions = nil
}

// AddCareerTaskIDs adds the "careerTasks" edge to the CareerTask entity by ids.
func (m *UserCareerMutation) AddCareerTaskIDs(ids ...int) {
	if m.careerTasks == nil {
		m.careerTasks = make(map[int]struct{})
	}
	for i := range ids {
		m.careerTasks[ids[i]] = struct{}{}
	}
}

// ClearCareerTasks clears the "careerTasks" edge to the CareerTask entity.
func (m *UserCareerMutation) ClearCareerTasks() {
	m.clearedcareerTasks = true
}

// CareerTasksCleared reports if the "careerTasks" edge to the CareerTask entity was cleared.
func (m *UserCareerMutation) CareerTasksCleared() bool {
	return m.clearedcareerTasks
}

// RemoveCareerTaskIDs removes the "careerTasks" edge to the CareerTask entity by IDs.
func (m *UserCareerMutation) RemoveCareerTaskIDs(ids ...int) {
	if m.removedcareerTasks == nil {
		m.removedcareerTasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.careerTasks, ids[i])
		m.removedcareerTasks[ids[i]] = struct{}{}
	}
}

// RemovedCareerTasks returns the removed IDs of the "careerTasks" edge to the CareerTask entity.
func (m *UserCareerMutation) RemovedCareerTasksIDs() (ids []int) {
	for id := range m.removedcareerTasks {
		ids = append(ids, id)
	}
	return
}

// CareerTasksIDs returns the "careerTasks" edge IDs in the mutation.
func (m *UserCareerMutation) CareerTasksIDs() (ids []int) {
	for id := range m.careerTasks {
		ids = append(ids, id)
	}
	return
}

// ResetCareerTasks resets all changes to the "careerTasks" edge.
func (m *UserCareerMutation) ResetCareerTasks() {
	m.careerTasks = nil
	m.clearedcareerTasks = false
	m.removedcareerTasks = nil
}

// AddCareerSkillGroupIDs adds the "careerSkillGroups" edge to the CareerSkillGroup entity by ids.
func (m *UserCareerMutation) AddCareerSkillGroupIDs(ids ...int) {
	if m.careerSkillGroups == nil {
		m.careerSkillGroups = make(map[int]struct{})
	}
	for i := range ids {
		m.careerSkillGroups[ids[i]] = struct{}{}
	}
}

// ClearCareerSkillGroups clears the "careerSkillGroups" edge to the CareerSkillGroup entity.
func (m *UserCareerMutation) ClearCareerSkillGroups() {
	m.clearedcareerSkillGroups = true
}

// CareerSkillGroupsCleared reports if the "careerSkillGroups" edge to the CareerSkillGroup entity was cleared.
func (m *UserCareerMutation) CareerSkillGroupsCleared() bool {
	return m.clearedcareerSkillGroups
}

// RemoveCareerSkillGroupIDs removes the "careerSkillGroups" edge to the CareerSkillGroup entity by IDs.
func (m *UserCareerMutation) RemoveCareerSkillGroupIDs(ids ...int) {
	if m.removedcareerSkillGroups == nil {
		m.removedcareerSkillGroups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.careerSkillGroups, ids[i])
		m.removedcareerSkillGroups[ids[i]] = struct{}{}
	}
}

// RemovedCareerSkillGroups returns the removed IDs of the "careerSkillGroups" edge to the CareerSkillGroup entity.
func (m *UserCareerMutation) RemovedCareerSkillGroupsIDs() (ids []int) {
	for id := range m.removedcareerSkillGroups {
		ids = append(ids, id)
	}
	return
}

// CareerSkillGroupsIDs returns the "careerSkillGroups" edge IDs in the mutation.
func (m *UserCareerMutation) CareerSkillGroupsIDs() (ids []int) {
	for id := range m.careerSkillGroups {
		ids = append(ids, id)
	}
	return
}

// ResetCareerSkillGroups resets all changes to the "careerSkillGroups" edge.
func (m *UserCareerMutation) ResetCareerSkillGroups() {
	m.careerSkillGroups = nil
	m.clearedcareerSkillGroups = false
	m.removedcareerSkillGroups = nil
}

// Where appends a list predicates to the UserCareerMutation builder.
func (m *UserCareerMutation) Where(ps ...predicate.UserCareer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserCareerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserCareerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserCareer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserCareerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserCareerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserCareer).
func (m *UserCareerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserCareerMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, usercareer.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, usercareer.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, usercareer.FieldName)
	}
	if m.from != nil {
		fields = append(fields, usercareer.FieldFrom)
	}
	if m.to != nil {
		fields = append(fields, usercareer.FieldTo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserCareerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usercareer.FieldCreateTime:
		return m.CreateTime()
	case usercareer.FieldUpdateTime:
		return m.UpdateTime()
	case usercareer.FieldName:
		return m.Name()
	case usercareer.FieldFrom:
		return m.From()
	case usercareer.FieldTo:
		return m.To()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserCareerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usercareer.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case usercareer.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case usercareer.FieldName:
		return m.OldName(ctx)
	case usercareer.FieldFrom:
		return m.OldFrom(ctx)
	case usercareer.FieldTo:
		return m.OldTo(ctx)
	}
	return nil, fmt.Errorf("unknown UserCareer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCareerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usercareer.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case usercareer.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case usercareer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case usercareer.FieldFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrom(v)
		return nil
	case usercareer.FieldTo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTo(v)
		return nil
	}
	return fmt.Errorf("unknown UserCareer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserCareerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserCareerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCareerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserCareer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserCareerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usercareer.FieldTo) {
		fields = append(fields, usercareer.FieldTo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserCareerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserCareerMutation) ClearField(name string) error {
	switch name {
	case usercareer.FieldTo:
		m.ClearTo()
		return nil
	}
	return fmt.Errorf("unknown UserCareer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserCareerMutation) ResetField(name string) error {
	switch name {
	case usercareer.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case usercareer.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case usercareer.FieldName:
		m.ResetName()
		return nil
	case usercareer.FieldFrom:
		m.ResetFrom()
		return nil
	case usercareer.FieldTo:
		m.ResetTo()
		return nil
	}
	return fmt.Errorf("unknown UserCareer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserCareerMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.careerGroup != nil {
		edges = append(edges, usercareer.EdgeCareerGroup)
	}
	if m.careerDescriptions != nil {
		edges = append(edges, usercareer.EdgeCareerDescriptions)
	}
	if m.careerTasks != nil {
		edges = append(edges, usercareer.EdgeCareerTasks)
	}
	if m.careerSkillGroups != nil {
		edges = append(edges, usercareer.EdgeCareerSkillGroups)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserCareerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usercareer.EdgeCareerGroup:
		if id := m.careerGroup; id != nil {
			return []ent.Value{*id}
		}
	case usercareer.EdgeCareerDescriptions:
		ids := make([]ent.Value, 0, len(m.careerDescriptions))
		for id := range m.careerDescriptions {
			ids = append(ids, id)
		}
		return ids
	case usercareer.EdgeCareerTasks:
		ids := make([]ent.Value, 0, len(m.careerTasks))
		for id := range m.careerTasks {
			ids = append(ids, id)
		}
		return ids
	case usercareer.EdgeCareerSkillGroups:
		ids := make([]ent.Value, 0, len(m.careerSkillGroups))
		for id := range m.careerSkillGroups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserCareerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcareerDescriptions != nil {
		edges = append(edges, usercareer.EdgeCareerDescriptions)
	}
	if m.removedcareerTasks != nil {
		edges = append(edges, usercareer.EdgeCareerTasks)
	}
	if m.removedcareerSkillGroups != nil {
		edges = append(edges, usercareer.EdgeCareerSkillGroups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserCareerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case usercareer.EdgeCareerDescriptions:
		ids := make([]ent.Value, 0, len(m.removedcareerDescriptions))
		for id := range m.removedcareerDescriptions {
			ids = append(ids, id)
		}
		return ids
	case usercareer.EdgeCareerTasks:
		ids := make([]ent.Value, 0, len(m.removedcareerTasks))
		for id := range m.removedcareerTasks {
			ids = append(ids, id)
		}
		return ids
	case usercareer.EdgeCareerSkillGroups:
		ids := make([]ent.Value, 0, len(m.removedcareerSkillGroups))
		for id := range m.removedcareerSkillGroups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserCareerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcareerGroup {
		edges = append(edges, usercareer.EdgeCareerGroup)
	}
	if m.clearedcareerDescriptions {
		edges = append(edges, usercareer.EdgeCareerDescriptions)
	}
	if m.clearedcareerTasks {
		edges = append(edges, usercareer.EdgeCareerTasks)
	}
	if m.clearedcareerSkillGroups {
		edges = append(edges, usercareer.EdgeCareerSkillGroups)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserCareerMutation) EdgeCleared(name string) bool {
	switch name {
	case usercareer.EdgeCareerGroup:
		return m.clearedcareerGroup
	case usercareer.EdgeCareerDescriptions:
		return m.clearedcareerDescriptions
	case usercareer.EdgeCareerTasks:
		return m.clearedcareerTasks
	case usercareer.EdgeCareerSkillGroups:
		return m.clearedcareerSkillGroups
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserCareerMutation) ClearEdge(name string) error {
	switch name {
	case usercareer.EdgeCareerGroup:
		m.ClearCareerGroup()
		return nil
	}
	return fmt.Errorf("unknown UserCareer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserCareerMutation) ResetEdge(name string) error {
	switch name {
	case usercareer.EdgeCareerGroup:
		m.ResetCareerGroup()
		return nil
	case usercareer.EdgeCareerDescriptions:
		m.ResetCareerDescriptions()
		return nil
	case usercareer.EdgeCareerTasks:
		m.ResetCareerTasks()
		return nil
	case usercareer.EdgeCareerSkillGroups:
		m.ResetCareerSkillGroups()
		return nil
	}
	return fmt.Errorf("unknown UserCareer edge %s", name)
}

// UserCareerDescriptionMutation represents an operation that mutates the UserCareerDescription nodes in the graph.
type UserCareerDescriptionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	description   *string
	clearedFields map[string]struct{}
	career        *int
	clearedcareer bool
	done          bool
	oldValue      func(context.Context) (*UserCareerDescription, error)
	predicates    []predicate.UserCareerDescription
}

var _ ent.Mutation = (*UserCareerDescriptionMutation)(nil)

// usercareerdescriptionOption allows management of the mutation configuration using functional options.
type usercareerdescriptionOption func(*UserCareerDescriptionMutation)

// newUserCareerDescriptionMutation creates new mutation for the UserCareerDescription entity.
func newUserCareerDescriptionMutation(c config, op Op, opts ...usercareerdescriptionOption) *UserCareerDescriptionMutation {
	m := &UserCareerDescriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserCareerDescription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserCareerDescriptionID sets the ID field of the mutation.
func withUserCareerDescriptionID(id int) usercareerdescriptionOption {
	return func(m *UserCareerDescriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserCareerDescription
		)
		m.oldValue = func(ctx context.Context) (*UserCareerDescription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserCareerDescription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserCareerDescription sets the old UserCareerDescription of the mutation.
func withUserCareerDescription(node *UserCareerDescription) usercareerdescriptionOption {
	return func(m *UserCareerDescriptionMutation) {
		m.oldValue = func(context.Context) (*UserCareerDescription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserCareerDescriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserCareerDescriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserCareerDescriptionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserCareerDescriptionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserCareerDescription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *UserCareerDescriptionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserCareerDescriptionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UserCareerDescription entity.
// If the UserCareerDescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCareerDescriptionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *UserCareerDescriptionMutation) ResetDescription() {
	m.description = nil
}

// SetCareerID sets the "career" edge to the UserCareer entity by id.
func (m *UserCareerDescriptionMutation) SetCareerID(id int) {
	m.career = &id
}

// ClearCareer clears the "career" edge to the UserCareer entity.
func (m *UserCareerDescriptionMutation) ClearCareer() {
	m.clearedcareer = true
}

// CareerCleared reports if the "career" edge to the UserCareer entity was cleared.
func (m *UserCareerDescriptionMutation) CareerCleared() bool {
	return m.clearedcareer
}

// CareerID returns the "career" edge ID in the mutation.
func (m *UserCareerDescriptionMutation) CareerID() (id int, exists bool) {
	if m.career != nil {
		return *m.career, true
	}
	return
}

// CareerIDs returns the "career" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CareerID instead. It exists only for internal usage by the builders.
func (m *UserCareerDescriptionMutation) CareerIDs() (ids []int) {
	if id := m.career; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCareer resets all changes to the "career" edge.
func (m *UserCareerDescriptionMutation) ResetCareer() {
	m.career = nil
	m.clearedcareer = false
}

// Where appends a list predicates to the UserCareerDescriptionMutation builder.
func (m *UserCareerDescriptionMutation) Where(ps ...predicate.UserCareerDescription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserCareerDescriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserCareerDescriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserCareerDescription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserCareerDescriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserCareerDescriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserCareerDescription).
func (m *UserCareerDescriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserCareerDescriptionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.description != nil {
		fields = append(fields, usercareerdescription.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserCareerDescriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usercareerdescription.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserCareerDescriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usercareerdescription.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown UserCareerDescription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCareerDescriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usercareerdescription.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown UserCareerDescription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserCareerDescriptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserCareerDescriptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCareerDescriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserCareerDescription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserCareerDescriptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserCareerDescriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserCareerDescriptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserCareerDescription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserCareerDescriptionMutation) ResetField(name string) error {
	switch name {
	case usercareerdescription.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown UserCareerDescription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserCareerDescriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.career != nil {
		edges = append(edges, usercareerdescription.EdgeCareer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserCareerDescriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usercareerdescription.EdgeCareer:
		if id := m.career; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserCareerDescriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserCareerDescriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserCareerDescriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcareer {
		edges = append(edges, usercareerdescription.EdgeCareer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserCareerDescriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case usercareerdescription.EdgeCareer:
		return m.clearedcareer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserCareerDescriptionMutation) ClearEdge(name string) error {
	switch name {
	case usercareerdescription.EdgeCareer:
		m.ClearCareer()
		return nil
	}
	return fmt.Errorf("unknown UserCareerDescription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserCareerDescriptionMutation) ResetEdge(name string) error {
	switch name {
	case usercareerdescription.EdgeCareer:
		m.ResetCareer()
		return nil
	}
	return fmt.Errorf("unknown UserCareerDescription edge %s", name)
}

// UserCareerGroupMutation represents an operation that mutates the UserCareerGroup nodes in the graph.
type UserCareerGroupMutation struct {
	config
	op             Op
	typ            string
	id             *int
	create_time    *time.Time
	update_time    *time.Time
	label          *string
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	careers        map[int]struct{}
	removedcareers map[int]struct{}
	clearedcareers bool
	done           bool
	oldValue       func(context.Context) (*UserCareerGroup, error)
	predicates     []predicate.UserCareerGroup
}

var _ ent.Mutation = (*UserCareerGroupMutation)(nil)

// usercareergroupOption allows management of the mutation configuration using functional options.
type usercareergroupOption func(*UserCareerGroupMutation)

// newUserCareerGroupMutation creates new mutation for the UserCareerGroup entity.
func newUserCareerGroupMutation(c config, op Op, opts ...usercareergroupOption) *UserCareerGroupMutation {
	m := &UserCareerGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeUserCareerGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserCareerGroupID sets the ID field of the mutation.
func withUserCareerGroupID(id int) usercareergroupOption {
	return func(m *UserCareerGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *UserCareerGroup
		)
		m.oldValue = func(ctx context.Context) (*UserCareerGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserCareerGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserCareerGroup sets the old UserCareerGroup of the mutation.
func withUserCareerGroup(node *UserCareerGroup) usercareergroupOption {
	return func(m *UserCareerGroupMutation) {
		m.oldValue = func(context.Context) (*UserCareerGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserCareerGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserCareerGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserCareerGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserCareerGroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserCareerGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserCareerGroupMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserCareerGroupMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserCareerGroup entity.
// If the UserCareerGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCareerGroupMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserCareerGroupMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserCareerGroupMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserCareerGroupMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserCareerGroup entity.
// If the UserCareerGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCareerGroupMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserCareerGroupMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetLabel sets the "label" field.
func (m *UserCareerGroupMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *UserCareerGroupMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the UserCareerGroup entity.
// If the UserCareerGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCareerGroupMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *UserCareerGroupMutation) ResetLabel() {
	m.label = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserCareerGroupMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserCareerGroupMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserCareerGroupMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserCareerGroupMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserCareerGroupMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserCareerGroupMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddCareerIDs adds the "careers" edge to the UserCareer entity by ids.
func (m *UserCareerGroupMutation) AddCareerIDs(ids ...int) {
	if m.careers == nil {
		m.careers = make(map[int]struct{})
	}
	for i := range ids {
		m.careers[ids[i]] = struct{}{}
	}
}

// ClearCareers clears the "careers" edge to the UserCareer entity.
func (m *UserCareerGroupMutation) ClearCareers() {
	m.clearedcareers = true
}

// CareersCleared reports if the "careers" edge to the UserCareer entity was cleared.
func (m *UserCareerGroupMutation) CareersCleared() bool {
	return m.clearedcareers
}

// RemoveCareerIDs removes the "careers" edge to the UserCareer entity by IDs.
func (m *UserCareerGroupMutation) RemoveCareerIDs(ids ...int) {
	if m.removedcareers == nil {
		m.removedcareers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.careers, ids[i])
		m.removedcareers[ids[i]] = struct{}{}
	}
}

// RemovedCareers returns the removed IDs of the "careers" edge to the UserCareer entity.
func (m *UserCareerGroupMutation) RemovedCareersIDs() (ids []int) {
	for id := range m.removedcareers {
		ids = append(ids, id)
	}
	return
}

// CareersIDs returns the "careers" edge IDs in the mutation.
func (m *UserCareerGroupMutation) CareersIDs() (ids []int) {
	for id := range m.careers {
		ids = append(ids, id)
	}
	return
}

// ResetCareers resets all changes to the "careers" edge.
func (m *UserCareerGroupMutation) ResetCareers() {
	m.careers = nil
	m.clearedcareers = false
	m.removedcareers = nil
}

// Where appends a list predicates to the UserCareerGroupMutation builder.
func (m *UserCareerGroupMutation) Where(ps ...predicate.UserCareerGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserCareerGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserCareerGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserCareerGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserCareerGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserCareerGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserCareerGroup).
func (m *UserCareerGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserCareerGroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, usercareergroup.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, usercareergroup.FieldUpdateTime)
	}
	if m.label != nil {
		fields = append(fields, usercareergroup.FieldLabel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserCareerGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usercareergroup.FieldCreateTime:
		return m.CreateTime()
	case usercareergroup.FieldUpdateTime:
		return m.UpdateTime()
	case usercareergroup.FieldLabel:
		return m.Label()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserCareerGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usercareergroup.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case usercareergroup.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case usercareergroup.FieldLabel:
		return m.OldLabel(ctx)
	}
	return nil, fmt.Errorf("unknown UserCareerGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCareerGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usercareergroup.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case usercareergroup.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case usercareergroup.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	}
	return fmt.Errorf("unknown UserCareerGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserCareerGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserCareerGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCareerGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserCareerGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserCareerGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserCareerGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserCareerGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserCareerGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserCareerGroupMutation) ResetField(name string) error {
	switch name {
	case usercareergroup.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case usercareergroup.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case usercareergroup.FieldLabel:
		m.ResetLabel()
		return nil
	}
	return fmt.Errorf("unknown UserCareerGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserCareerGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, usercareergroup.EdgeUser)
	}
	if m.careers != nil {
		edges = append(edges, usercareergroup.EdgeCareers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserCareerGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usercareergroup.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usercareergroup.EdgeCareers:
		ids := make([]ent.Value, 0, len(m.careers))
		for id := range m.careers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserCareerGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcareers != nil {
		edges = append(edges, usercareergroup.EdgeCareers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserCareerGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case usercareergroup.EdgeCareers:
		ids := make([]ent.Value, 0, len(m.removedcareers))
		for id := range m.removedcareers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserCareerGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, usercareergroup.EdgeUser)
	}
	if m.clearedcareers {
		edges = append(edges, usercareergroup.EdgeCareers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserCareerGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case usercareergroup.EdgeUser:
		return m.cleareduser
	case usercareergroup.EdgeCareers:
		return m.clearedcareers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserCareerGroupMutation) ClearEdge(name string) error {
	switch name {
	case usercareergroup.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserCareerGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserCareerGroupMutation) ResetEdge(name string) error {
	switch name {
	case usercareergroup.EdgeUser:
		m.ResetUser()
		return nil
	case usercareergroup.EdgeCareers:
		m.ResetCareers()
		return nil
	}
	return fmt.Errorf("unknown UserCareerGroup edge %s", name)
}

// UserNoteMutation represents an operation that mutates the UserNote nodes in the graph.
type UserNoteMutation struct {
	config
	op               Op
	typ              string
	id               *int
	create_time      *time.Time
	update_time      *time.Time
	label            *string
	memo             *string
	clearedFields    map[string]struct{}
	user             *int
	cleareduser      bool
	noteItems        map[int]struct{}
	removednoteItems map[int]struct{}
	clearednoteItems bool
	done             bool
	oldValue         func(context.Context) (*UserNote, error)
	predicates       []predicate.UserNote
}

var _ ent.Mutation = (*UserNoteMutation)(nil)

// usernoteOption allows management of the mutation configuration using functional options.
type usernoteOption func(*UserNoteMutation)

// newUserNoteMutation creates new mutation for the UserNote entity.
func newUserNoteMutation(c config, op Op, opts ...usernoteOption) *UserNoteMutation {
	m := &UserNoteMutation{
		config:        c,
		op:            op,
		typ:           TypeUserNote,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserNoteID sets the ID field of the mutation.
func withUserNoteID(id int) usernoteOption {
	return func(m *UserNoteMutation) {
		var (
			err   error
			once  sync.Once
			value *UserNote
		)
		m.oldValue = func(ctx context.Context) (*UserNote, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserNote.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserNote sets the old UserNote of the mutation.
func withUserNote(node *UserNote) usernoteOption {
	return func(m *UserNoteMutation) {
		m.oldValue = func(context.Context) (*UserNote, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserNoteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserNoteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserNoteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserNoteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserNote.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserNoteMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserNoteMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserNote entity.
// If the UserNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNoteMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserNoteMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserNoteMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserNoteMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserNote entity.
// If the UserNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNoteMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserNoteMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetLabel sets the "label" field.
func (m *UserNoteMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *UserNoteMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the UserNote entity.
// If the UserNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNoteMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *UserNoteMutation) ResetLabel() {
	m.label = nil
}

// SetMemo sets the "memo" field.
func (m *UserNoteMutation) SetMemo(s string) {
	m.memo = &s
}

// Memo returns the value of the "memo" field in the mutation.
func (m *UserNoteMutation) Memo() (r string, exists bool) {
	v := m.memo
	if v == nil {
		return
	}
	return *v, true
}

// OldMemo returns the old "memo" field's value of the UserNote entity.
// If the UserNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNoteMutation) OldMemo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemo: %w", err)
	}
	return oldValue.Memo, nil
}

// ClearMemo clears the value of the "memo" field.
func (m *UserNoteMutation) ClearMemo() {
	m.memo = nil
	m.clearedFields[usernote.FieldMemo] = struct{}{}
}

// MemoCleared returns if the "memo" field was cleared in this mutation.
func (m *UserNoteMutation) MemoCleared() bool {
	_, ok := m.clearedFields[usernote.FieldMemo]
	return ok
}

// ResetMemo resets all changes to the "memo" field.
func (m *UserNoteMutation) ResetMemo() {
	m.memo = nil
	delete(m.clearedFields, usernote.FieldMemo)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserNoteMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserNoteMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserNoteMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserNoteMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserNoteMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserNoteMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddNoteItemIDs adds the "noteItems" edge to the UserNoteItem entity by ids.
func (m *UserNoteMutation) AddNoteItemIDs(ids ...int) {
	if m.noteItems == nil {
		m.noteItems = make(map[int]struct{})
	}
	for i := range ids {
		m.noteItems[ids[i]] = struct{}{}
	}
}

// ClearNoteItems clears the "noteItems" edge to the UserNoteItem entity.
func (m *UserNoteMutation) ClearNoteItems() {
	m.clearednoteItems = true
}

// NoteItemsCleared reports if the "noteItems" edge to the UserNoteItem entity was cleared.
func (m *UserNoteMutation) NoteItemsCleared() bool {
	return m.clearednoteItems
}

// RemoveNoteItemIDs removes the "noteItems" edge to the UserNoteItem entity by IDs.
func (m *UserNoteMutation) RemoveNoteItemIDs(ids ...int) {
	if m.removednoteItems == nil {
		m.removednoteItems = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.noteItems, ids[i])
		m.removednoteItems[ids[i]] = struct{}{}
	}
}

// RemovedNoteItems returns the removed IDs of the "noteItems" edge to the UserNoteItem entity.
func (m *UserNoteMutation) RemovedNoteItemsIDs() (ids []int) {
	for id := range m.removednoteItems {
		ids = append(ids, id)
	}
	return
}

// NoteItemsIDs returns the "noteItems" edge IDs in the mutation.
func (m *UserNoteMutation) NoteItemsIDs() (ids []int) {
	for id := range m.noteItems {
		ids = append(ids, id)
	}
	return
}

// ResetNoteItems resets all changes to the "noteItems" edge.
func (m *UserNoteMutation) ResetNoteItems() {
	m.noteItems = nil
	m.clearednoteItems = false
	m.removednoteItems = nil
}

// Where appends a list predicates to the UserNoteMutation builder.
func (m *UserNoteMutation) Where(ps ...predicate.UserNote) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserNoteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserNoteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserNote, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserNoteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserNoteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserNote).
func (m *UserNoteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserNoteMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, usernote.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, usernote.FieldUpdateTime)
	}
	if m.label != nil {
		fields = append(fields, usernote.FieldLabel)
	}
	if m.memo != nil {
		fields = append(fields, usernote.FieldMemo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserNoteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usernote.FieldCreateTime:
		return m.CreateTime()
	case usernote.FieldUpdateTime:
		return m.UpdateTime()
	case usernote.FieldLabel:
		return m.Label()
	case usernote.FieldMemo:
		return m.Memo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserNoteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usernote.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case usernote.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case usernote.FieldLabel:
		return m.OldLabel(ctx)
	case usernote.FieldMemo:
		return m.OldMemo(ctx)
	}
	return nil, fmt.Errorf("unknown UserNote field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserNoteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usernote.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case usernote.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case usernote.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case usernote.FieldMemo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemo(v)
		return nil
	}
	return fmt.Errorf("unknown UserNote field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserNoteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserNoteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserNoteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserNote numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserNoteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usernote.FieldMemo) {
		fields = append(fields, usernote.FieldMemo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserNoteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserNoteMutation) ClearField(name string) error {
	switch name {
	case usernote.FieldMemo:
		m.ClearMemo()
		return nil
	}
	return fmt.Errorf("unknown UserNote nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserNoteMutation) ResetField(name string) error {
	switch name {
	case usernote.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case usernote.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case usernote.FieldLabel:
		m.ResetLabel()
		return nil
	case usernote.FieldMemo:
		m.ResetMemo()
		return nil
	}
	return fmt.Errorf("unknown UserNote field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserNoteMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, usernote.EdgeUser)
	}
	if m.noteItems != nil {
		edges = append(edges, usernote.EdgeNoteItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserNoteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usernote.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usernote.EdgeNoteItems:
		ids := make([]ent.Value, 0, len(m.noteItems))
		for id := range m.noteItems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserNoteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednoteItems != nil {
		edges = append(edges, usernote.EdgeNoteItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserNoteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case usernote.EdgeNoteItems:
		ids := make([]ent.Value, 0, len(m.removednoteItems))
		for id := range m.removednoteItems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserNoteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, usernote.EdgeUser)
	}
	if m.clearednoteItems {
		edges = append(edges, usernote.EdgeNoteItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserNoteMutation) EdgeCleared(name string) bool {
	switch name {
	case usernote.EdgeUser:
		return m.cleareduser
	case usernote.EdgeNoteItems:
		return m.clearednoteItems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserNoteMutation) ClearEdge(name string) error {
	switch name {
	case usernote.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserNote unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserNoteMutation) ResetEdge(name string) error {
	switch name {
	case usernote.EdgeUser:
		m.ResetUser()
		return nil
	case usernote.EdgeNoteItems:
		m.ResetNoteItems()
		return nil
	}
	return fmt.Errorf("unknown UserNote edge %s", name)
}

// UserNoteItemMutation represents an operation that mutates the UserNoteItem nodes in the graph.
type UserNoteItemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	text          *string
	clearedFields map[string]struct{}
	note          *int
	clearednote   bool
	done          bool
	oldValue      func(context.Context) (*UserNoteItem, error)
	predicates    []predicate.UserNoteItem
}

var _ ent.Mutation = (*UserNoteItemMutation)(nil)

// usernoteitemOption allows management of the mutation configuration using functional options.
type usernoteitemOption func(*UserNoteItemMutation)

// newUserNoteItemMutation creates new mutation for the UserNoteItem entity.
func newUserNoteItemMutation(c config, op Op, opts ...usernoteitemOption) *UserNoteItemMutation {
	m := &UserNoteItemMutation{
		config:        c,
		op:            op,
		typ:           TypeUserNoteItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserNoteItemID sets the ID field of the mutation.
func withUserNoteItemID(id int) usernoteitemOption {
	return func(m *UserNoteItemMutation) {
		var (
			err   error
			once  sync.Once
			value *UserNoteItem
		)
		m.oldValue = func(ctx context.Context) (*UserNoteItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserNoteItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserNoteItem sets the old UserNoteItem of the mutation.
func withUserNoteItem(node *UserNoteItem) usernoteitemOption {
	return func(m *UserNoteItemMutation) {
		m.oldValue = func(context.Context) (*UserNoteItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserNoteItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserNoteItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserNoteItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserNoteItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserNoteItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserNoteItemMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserNoteItemMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserNoteItem entity.
// If the UserNoteItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNoteItemMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserNoteItemMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserNoteItemMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserNoteItemMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserNoteItem entity.
// If the UserNoteItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNoteItemMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserNoteItemMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetText sets the "text" field.
func (m *UserNoteItemMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *UserNoteItemMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the UserNoteItem entity.
// If the UserNoteItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNoteItemMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *UserNoteItemMutation) ResetText() {
	m.text = nil
}

// SetNoteID sets the "note" edge to the UserNote entity by id.
func (m *UserNoteItemMutation) SetNoteID(id int) {
	m.note = &id
}

// ClearNote clears the "note" edge to the UserNote entity.
func (m *UserNoteItemMutation) ClearNote() {
	m.clearednote = true
}

// NoteCleared reports if the "note" edge to the UserNote entity was cleared.
func (m *UserNoteItemMutation) NoteCleared() bool {
	return m.clearednote
}

// NoteID returns the "note" edge ID in the mutation.
func (m *UserNoteItemMutation) NoteID() (id int, exists bool) {
	if m.note != nil {
		return *m.note, true
	}
	return
}

// NoteIDs returns the "note" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NoteID instead. It exists only for internal usage by the builders.
func (m *UserNoteItemMutation) NoteIDs() (ids []int) {
	if id := m.note; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNote resets all changes to the "note" edge.
func (m *UserNoteItemMutation) ResetNote() {
	m.note = nil
	m.clearednote = false
}

// Where appends a list predicates to the UserNoteItemMutation builder.
func (m *UserNoteItemMutation) Where(ps ...predicate.UserNoteItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserNoteItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserNoteItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserNoteItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserNoteItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserNoteItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserNoteItem).
func (m *UserNoteItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserNoteItemMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, usernoteitem.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, usernoteitem.FieldUpdateTime)
	}
	if m.text != nil {
		fields = append(fields, usernoteitem.FieldText)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserNoteItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usernoteitem.FieldCreateTime:
		return m.CreateTime()
	case usernoteitem.FieldUpdateTime:
		return m.UpdateTime()
	case usernoteitem.FieldText:
		return m.Text()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserNoteItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usernoteitem.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case usernoteitem.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case usernoteitem.FieldText:
		return m.OldText(ctx)
	}
	return nil, fmt.Errorf("unknown UserNoteItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserNoteItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usernoteitem.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case usernoteitem.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case usernoteitem.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	}
	return fmt.Errorf("unknown UserNoteItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserNoteItemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserNoteItemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserNoteItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserNoteItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserNoteItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserNoteItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserNoteItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserNoteItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserNoteItemMutation) ResetField(name string) error {
	switch name {
	case usernoteitem.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case usernoteitem.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case usernoteitem.FieldText:
		m.ResetText()
		return nil
	}
	return fmt.Errorf("unknown UserNoteItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserNoteItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.note != nil {
		edges = append(edges, usernoteitem.EdgeNote)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserNoteItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usernoteitem.EdgeNote:
		if id := m.note; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserNoteItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserNoteItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserNoteItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednote {
		edges = append(edges, usernoteitem.EdgeNote)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserNoteItemMutation) EdgeCleared(name string) bool {
	switch name {
	case usernoteitem.EdgeNote:
		return m.clearednote
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserNoteItemMutation) ClearEdge(name string) error {
	switch name {
	case usernoteitem.EdgeNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown UserNoteItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserNoteItemMutation) ResetEdge(name string) error {
	switch name {
	case usernoteitem.EdgeNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown UserNoteItem edge %s", name)
}

// UserQualificationMutation represents an operation that mutates the UserQualification nodes in the graph.
type UserQualificationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	name          *string
	organization  *string
	url           *string
	got_date      *string
	memo          *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserQualification, error)
	predicates    []predicate.UserQualification
}

var _ ent.Mutation = (*UserQualificationMutation)(nil)

// userqualificationOption allows management of the mutation configuration using functional options.
type userqualificationOption func(*UserQualificationMutation)

// newUserQualificationMutation creates new mutation for the UserQualification entity.
func newUserQualificationMutation(c config, op Op, opts ...userqualificationOption) *UserQualificationMutation {
	m := &UserQualificationMutation{
		config:        c,
		op:            op,
		typ:           TypeUserQualification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserQualificationID sets the ID field of the mutation.
func withUserQualificationID(id int) userqualificationOption {
	return func(m *UserQualificationMutation) {
		var (
			err   error
			once  sync.Once
			value *UserQualification
		)
		m.oldValue = func(ctx context.Context) (*UserQualification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserQualification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserQualification sets the old UserQualification of the mutation.
func withUserQualification(node *UserQualification) userqualificationOption {
	return func(m *UserQualificationMutation) {
		m.oldValue = func(context.Context) (*UserQualification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserQualificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserQualificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserQualificationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserQualificationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserQualification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserQualificationMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserQualificationMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserQualification entity.
// If the UserQualification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserQualificationMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserQualificationMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserQualificationMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserQualificationMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserQualification entity.
// If the UserQualification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserQualificationMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserQualificationMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *UserQualificationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserQualificationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UserQualification entity.
// If the UserQualification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserQualificationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserQualificationMutation) ResetName() {
	m.name = nil
}

// SetOrganization sets the "organization" field.
func (m *UserQualificationMutation) SetOrganization(s string) {
	m.organization = &s
}

// Organization returns the value of the "organization" field in the mutation.
func (m *UserQualificationMutation) Organization() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganization returns the old "organization" field's value of the UserQualification entity.
// If the UserQualification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserQualificationMutation) OldOrganization(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganization: %w", err)
	}
	return oldValue.Organization, nil
}

// ClearOrganization clears the value of the "organization" field.
func (m *UserQualificationMutation) ClearOrganization() {
	m.organization = nil
	m.clearedFields[userqualification.FieldOrganization] = struct{}{}
}

// OrganizationCleared returns if the "organization" field was cleared in this mutation.
func (m *UserQualificationMutation) OrganizationCleared() bool {
	_, ok := m.clearedFields[userqualification.FieldOrganization]
	return ok
}

// ResetOrganization resets all changes to the "organization" field.
func (m *UserQualificationMutation) ResetOrganization() {
	m.organization = nil
	delete(m.clearedFields, userqualification.FieldOrganization)
}

// SetURL sets the "url" field.
func (m *UserQualificationMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *UserQualificationMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the UserQualification entity.
// If the UserQualification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserQualificationMutation) OldURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *UserQualificationMutation) ClearURL() {
	m.url = nil
	m.clearedFields[userqualification.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *UserQualificationMutation) URLCleared() bool {
	_, ok := m.clearedFields[userqualification.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *UserQualificationMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, userqualification.FieldURL)
}

// SetGotDate sets the "got_date" field.
func (m *UserQualificationMutation) SetGotDate(s string) {
	m.got_date = &s
}

// GotDate returns the value of the "got_date" field in the mutation.
func (m *UserQualificationMutation) GotDate() (r string, exists bool) {
	v := m.got_date
	if v == nil {
		return
	}
	return *v, true
}

// OldGotDate returns the old "got_date" field's value of the UserQualification entity.
// If the UserQualification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserQualificationMutation) OldGotDate(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGotDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGotDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGotDate: %w", err)
	}
	return oldValue.GotDate, nil
}

// ClearGotDate clears the value of the "got_date" field.
func (m *UserQualificationMutation) ClearGotDate() {
	m.got_date = nil
	m.clearedFields[userqualification.FieldGotDate] = struct{}{}
}

// GotDateCleared returns if the "got_date" field was cleared in this mutation.
func (m *UserQualificationMutation) GotDateCleared() bool {
	_, ok := m.clearedFields[userqualification.FieldGotDate]
	return ok
}

// ResetGotDate resets all changes to the "got_date" field.
func (m *UserQualificationMutation) ResetGotDate() {
	m.got_date = nil
	delete(m.clearedFields, userqualification.FieldGotDate)
}

// SetMemo sets the "memo" field.
func (m *UserQualificationMutation) SetMemo(s string) {
	m.memo = &s
}

// Memo returns the value of the "memo" field in the mutation.
func (m *UserQualificationMutation) Memo() (r string, exists bool) {
	v := m.memo
	if v == nil {
		return
	}
	return *v, true
}

// OldMemo returns the old "memo" field's value of the UserQualification entity.
// If the UserQualification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserQualificationMutation) OldMemo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemo: %w", err)
	}
	return oldValue.Memo, nil
}

// ClearMemo clears the value of the "memo" field.
func (m *UserQualificationMutation) ClearMemo() {
	m.memo = nil
	m.clearedFields[userqualification.FieldMemo] = struct{}{}
}

// MemoCleared returns if the "memo" field was cleared in this mutation.
func (m *UserQualificationMutation) MemoCleared() bool {
	_, ok := m.clearedFields[userqualification.FieldMemo]
	return ok
}

// ResetMemo resets all changes to the "memo" field.
func (m *UserQualificationMutation) ResetMemo() {
	m.memo = nil
	delete(m.clearedFields, userqualification.FieldMemo)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserQualificationMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserQualificationMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserQualificationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserQualificationMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserQualificationMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserQualificationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserQualificationMutation builder.
func (m *UserQualificationMutation) Where(ps ...predicate.UserQualification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserQualificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserQualificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserQualification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserQualificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserQualificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserQualification).
func (m *UserQualificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserQualificationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, userqualification.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, userqualification.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, userqualification.FieldName)
	}
	if m.organization != nil {
		fields = append(fields, userqualification.FieldOrganization)
	}
	if m.url != nil {
		fields = append(fields, userqualification.FieldURL)
	}
	if m.got_date != nil {
		fields = append(fields, userqualification.FieldGotDate)
	}
	if m.memo != nil {
		fields = append(fields, userqualification.FieldMemo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserQualificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userqualification.FieldCreateTime:
		return m.CreateTime()
	case userqualification.FieldUpdateTime:
		return m.UpdateTime()
	case userqualification.FieldName:
		return m.Name()
	case userqualification.FieldOrganization:
		return m.Organization()
	case userqualification.FieldURL:
		return m.URL()
	case userqualification.FieldGotDate:
		return m.GotDate()
	case userqualification.FieldMemo:
		return m.Memo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserQualificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userqualification.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case userqualification.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case userqualification.FieldName:
		return m.OldName(ctx)
	case userqualification.FieldOrganization:
		return m.OldOrganization(ctx)
	case userqualification.FieldURL:
		return m.OldURL(ctx)
	case userqualification.FieldGotDate:
		return m.OldGotDate(ctx)
	case userqualification.FieldMemo:
		return m.OldMemo(ctx)
	}
	return nil, fmt.Errorf("unknown UserQualification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserQualificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userqualification.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case userqualification.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case userqualification.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case userqualification.FieldOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganization(v)
		return nil
	case userqualification.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case userqualification.FieldGotDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGotDate(v)
		return nil
	case userqualification.FieldMemo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemo(v)
		return nil
	}
	return fmt.Errorf("unknown UserQualification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserQualificationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserQualificationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserQualificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserQualification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserQualificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userqualification.FieldOrganization) {
		fields = append(fields, userqualification.FieldOrganization)
	}
	if m.FieldCleared(userqualification.FieldURL) {
		fields = append(fields, userqualification.FieldURL)
	}
	if m.FieldCleared(userqualification.FieldGotDate) {
		fields = append(fields, userqualification.FieldGotDate)
	}
	if m.FieldCleared(userqualification.FieldMemo) {
		fields = append(fields, userqualification.FieldMemo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserQualificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserQualificationMutation) ClearField(name string) error {
	switch name {
	case userqualification.FieldOrganization:
		m.ClearOrganization()
		return nil
	case userqualification.FieldURL:
		m.ClearURL()
		return nil
	case userqualification.FieldGotDate:
		m.ClearGotDate()
		return nil
	case userqualification.FieldMemo:
		m.ClearMemo()
		return nil
	}
	return fmt.Errorf("unknown UserQualification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserQualificationMutation) ResetField(name string) error {
	switch name {
	case userqualification.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case userqualification.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case userqualification.FieldName:
		m.ResetName()
		return nil
	case userqualification.FieldOrganization:
		m.ResetOrganization()
		return nil
	case userqualification.FieldURL:
		m.ResetURL()
		return nil
	case userqualification.FieldGotDate:
		m.ResetGotDate()
		return nil
	case userqualification.FieldMemo:
		m.ResetMemo()
		return nil
	}
	return fmt.Errorf("unknown UserQualification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserQualificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userqualification.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserQualificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userqualification.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserQualificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserQualificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserQualificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userqualification.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserQualificationMutation) EdgeCleared(name string) bool {
	switch name {
	case userqualification.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserQualificationMutation) ClearEdge(name string) error {
	switch name {
	case userqualification.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserQualification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserQualificationMutation) ResetEdge(name string) error {
	switch name {
	case userqualification.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserQualification edge %s", name)
}
