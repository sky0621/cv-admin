// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/sky0621/cv-admin/src/ent/careerskill"
	"github.com/sky0621/cv-admin/src/ent/careerskillgroup"
	"github.com/sky0621/cv-admin/src/ent/careertask"
	"github.com/sky0621/cv-admin/src/ent/predicate"
	"github.com/sky0621/cv-admin/src/ent/user"
	"github.com/sky0621/cv-admin/src/ent/useractivity"
	"github.com/sky0621/cv-admin/src/ent/usercareer"
	"github.com/sky0621/cv-admin/src/ent/usercareergroup"
	"github.com/sky0621/cv-admin/src/ent/usernote"
	"github.com/sky0621/cv-admin/src/ent/usernoteitem"
	"github.com/sky0621/cv-admin/src/ent/userqualification"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCareerSkill       = "CareerSkill"
	TypeCareerSkillGroup  = "CareerSkillGroup"
	TypeCareerTask        = "CareerTask"
	TypeUser              = "User"
	TypeUserActivity      = "UserActivity"
	TypeUserCareer        = "UserCareer"
	TypeUserCareerGroup   = "UserCareerGroup"
	TypeUserNote          = "UserNote"
	TypeUserNoteItem      = "UserNoteItem"
	TypeUserQualification = "UserQualification"
)

// CareerSkillMutation represents an operation that mutates the CareerSkill nodes in the graph.
type CareerSkillMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CareerSkill, error)
	predicates    []predicate.CareerSkill
}

var _ ent.Mutation = (*CareerSkillMutation)(nil)

// careerskillOption allows management of the mutation configuration using functional options.
type careerskillOption func(*CareerSkillMutation)

// newCareerSkillMutation creates new mutation for the CareerSkill entity.
func newCareerSkillMutation(c config, op Op, opts ...careerskillOption) *CareerSkillMutation {
	m := &CareerSkillMutation{
		config:        c,
		op:            op,
		typ:           TypeCareerSkill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCareerSkillID sets the ID field of the mutation.
func withCareerSkillID(id int) careerskillOption {
	return func(m *CareerSkillMutation) {
		var (
			err   error
			once  sync.Once
			value *CareerSkill
		)
		m.oldValue = func(ctx context.Context) (*CareerSkill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CareerSkill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCareerSkill sets the old CareerSkill of the mutation.
func withCareerSkill(node *CareerSkill) careerskillOption {
	return func(m *CareerSkillMutation) {
		m.oldValue = func(context.Context) (*CareerSkill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CareerSkillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CareerSkillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CareerSkillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CareerSkillMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CareerSkill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CareerSkillMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CareerSkillMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CareerSkill entity.
// If the CareerSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CareerSkillMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CareerSkillMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CareerSkillMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CareerSkillMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CareerSkill entity.
// If the CareerSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CareerSkillMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CareerSkillMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the CareerSkillMutation builder.
func (m *CareerSkillMutation) Where(ps ...predicate.CareerSkill) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CareerSkillMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CareerSkill).
func (m *CareerSkillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CareerSkillMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.create_time != nil {
		fields = append(fields, careerskill.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, careerskill.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CareerSkillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case careerskill.FieldCreateTime:
		return m.CreateTime()
	case careerskill.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CareerSkillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case careerskill.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case careerskill.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown CareerSkill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CareerSkillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case careerskill.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case careerskill.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown CareerSkill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CareerSkillMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CareerSkillMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CareerSkillMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CareerSkill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CareerSkillMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CareerSkillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CareerSkillMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CareerSkill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CareerSkillMutation) ResetField(name string) error {
	switch name {
	case careerskill.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case careerskill.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown CareerSkill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CareerSkillMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CareerSkillMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CareerSkillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CareerSkillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CareerSkillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CareerSkillMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CareerSkillMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CareerSkill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CareerSkillMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CareerSkill edge %s", name)
}

// CareerSkillGroupMutation represents an operation that mutates the CareerSkillGroup nodes in the graph.
type CareerSkillGroupMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CareerSkillGroup, error)
	predicates    []predicate.CareerSkillGroup
}

var _ ent.Mutation = (*CareerSkillGroupMutation)(nil)

// careerskillgroupOption allows management of the mutation configuration using functional options.
type careerskillgroupOption func(*CareerSkillGroupMutation)

// newCareerSkillGroupMutation creates new mutation for the CareerSkillGroup entity.
func newCareerSkillGroupMutation(c config, op Op, opts ...careerskillgroupOption) *CareerSkillGroupMutation {
	m := &CareerSkillGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeCareerSkillGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCareerSkillGroupID sets the ID field of the mutation.
func withCareerSkillGroupID(id int) careerskillgroupOption {
	return func(m *CareerSkillGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *CareerSkillGroup
		)
		m.oldValue = func(ctx context.Context) (*CareerSkillGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CareerSkillGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCareerSkillGroup sets the old CareerSkillGroup of the mutation.
func withCareerSkillGroup(node *CareerSkillGroup) careerskillgroupOption {
	return func(m *CareerSkillGroupMutation) {
		m.oldValue = func(context.Context) (*CareerSkillGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CareerSkillGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CareerSkillGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CareerSkillGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CareerSkillGroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CareerSkillGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CareerSkillGroupMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CareerSkillGroupMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CareerSkillGroup entity.
// If the CareerSkillGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CareerSkillGroupMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CareerSkillGroupMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CareerSkillGroupMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CareerSkillGroupMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CareerSkillGroup entity.
// If the CareerSkillGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CareerSkillGroupMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CareerSkillGroupMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the CareerSkillGroupMutation builder.
func (m *CareerSkillGroupMutation) Where(ps ...predicate.CareerSkillGroup) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CareerSkillGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CareerSkillGroup).
func (m *CareerSkillGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CareerSkillGroupMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.create_time != nil {
		fields = append(fields, careerskillgroup.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, careerskillgroup.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CareerSkillGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case careerskillgroup.FieldCreateTime:
		return m.CreateTime()
	case careerskillgroup.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CareerSkillGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case careerskillgroup.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case careerskillgroup.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown CareerSkillGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CareerSkillGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case careerskillgroup.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case careerskillgroup.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown CareerSkillGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CareerSkillGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CareerSkillGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CareerSkillGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CareerSkillGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CareerSkillGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CareerSkillGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CareerSkillGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CareerSkillGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CareerSkillGroupMutation) ResetField(name string) error {
	switch name {
	case careerskillgroup.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case careerskillgroup.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown CareerSkillGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CareerSkillGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CareerSkillGroupMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CareerSkillGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CareerSkillGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CareerSkillGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CareerSkillGroupMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CareerSkillGroupMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CareerSkillGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CareerSkillGroupMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CareerSkillGroup edge %s", name)
}

// CareerTaskMutation represents an operation that mutates the CareerTask nodes in the graph.
type CareerTaskMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CareerTask, error)
	predicates    []predicate.CareerTask
}

var _ ent.Mutation = (*CareerTaskMutation)(nil)

// careertaskOption allows management of the mutation configuration using functional options.
type careertaskOption func(*CareerTaskMutation)

// newCareerTaskMutation creates new mutation for the CareerTask entity.
func newCareerTaskMutation(c config, op Op, opts ...careertaskOption) *CareerTaskMutation {
	m := &CareerTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeCareerTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCareerTaskID sets the ID field of the mutation.
func withCareerTaskID(id int) careertaskOption {
	return func(m *CareerTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *CareerTask
		)
		m.oldValue = func(ctx context.Context) (*CareerTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CareerTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCareerTask sets the old CareerTask of the mutation.
func withCareerTask(node *CareerTask) careertaskOption {
	return func(m *CareerTaskMutation) {
		m.oldValue = func(context.Context) (*CareerTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CareerTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CareerTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CareerTaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CareerTaskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CareerTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CareerTaskMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CareerTaskMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CareerTask entity.
// If the CareerTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CareerTaskMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CareerTaskMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CareerTaskMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CareerTaskMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CareerTask entity.
// If the CareerTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CareerTaskMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CareerTaskMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the CareerTaskMutation builder.
func (m *CareerTaskMutation) Where(ps ...predicate.CareerTask) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CareerTaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CareerTask).
func (m *CareerTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CareerTaskMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.create_time != nil {
		fields = append(fields, careertask.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, careertask.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CareerTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case careertask.FieldCreateTime:
		return m.CreateTime()
	case careertask.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CareerTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case careertask.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case careertask.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown CareerTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CareerTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case careertask.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case careertask.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown CareerTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CareerTaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CareerTaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CareerTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CareerTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CareerTaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CareerTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CareerTaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CareerTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CareerTaskMutation) ResetField(name string) error {
	switch name {
	case careertask.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case careertask.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown CareerTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CareerTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CareerTaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CareerTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CareerTaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CareerTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CareerTaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CareerTaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CareerTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CareerTaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CareerTask edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                Op
	typ               string
	id                *int
	create_time       *time.Time
	update_time       *time.Time
	key               *string
	name              *string
	nickname          *string
	avatar_url        *string
	birthday_year     *int
	addbirthday_year  *int
	birthday_month    *int
	addbirthday_month *int
	birthday_day      *int
	addbirthday_day   *int
	job               *string
	belong_to         *string
	pr                *string
	clearedFields     map[string]struct{}
	activities        map[int]struct{}
	removedactivities map[int]struct{}
	clearedactivities bool
	done              bool
	oldValue          func(context.Context) (*User, error)
	predicates        []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetKey sets the "key" field.
func (m *UserMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *UserMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *UserMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetNickname sets the "nickname" field.
func (m *UserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickname(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *UserMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[user.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *UserMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[user.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, user.FieldNickname)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// SetBirthdayYear sets the "birthday_year" field.
func (m *UserMutation) SetBirthdayYear(i int) {
	m.birthday_year = &i
	m.addbirthday_year = nil
}

// BirthdayYear returns the value of the "birthday_year" field in the mutation.
func (m *UserMutation) BirthdayYear() (r int, exists bool) {
	v := m.birthday_year
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthdayYear returns the old "birthday_year" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthdayYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthdayYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthdayYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthdayYear: %w", err)
	}
	return oldValue.BirthdayYear, nil
}

// AddBirthdayYear adds i to the "birthday_year" field.
func (m *UserMutation) AddBirthdayYear(i int) {
	if m.addbirthday_year != nil {
		*m.addbirthday_year += i
	} else {
		m.addbirthday_year = &i
	}
}

// AddedBirthdayYear returns the value that was added to the "birthday_year" field in this mutation.
func (m *UserMutation) AddedBirthdayYear() (r int, exists bool) {
	v := m.addbirthday_year
	if v == nil {
		return
	}
	return *v, true
}

// ResetBirthdayYear resets all changes to the "birthday_year" field.
func (m *UserMutation) ResetBirthdayYear() {
	m.birthday_year = nil
	m.addbirthday_year = nil
}

// SetBirthdayMonth sets the "birthday_month" field.
func (m *UserMutation) SetBirthdayMonth(i int) {
	m.birthday_month = &i
	m.addbirthday_month = nil
}

// BirthdayMonth returns the value of the "birthday_month" field in the mutation.
func (m *UserMutation) BirthdayMonth() (r int, exists bool) {
	v := m.birthday_month
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthdayMonth returns the old "birthday_month" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthdayMonth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthdayMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthdayMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthdayMonth: %w", err)
	}
	return oldValue.BirthdayMonth, nil
}

// AddBirthdayMonth adds i to the "birthday_month" field.
func (m *UserMutation) AddBirthdayMonth(i int) {
	if m.addbirthday_month != nil {
		*m.addbirthday_month += i
	} else {
		m.addbirthday_month = &i
	}
}

// AddedBirthdayMonth returns the value that was added to the "birthday_month" field in this mutation.
func (m *UserMutation) AddedBirthdayMonth() (r int, exists bool) {
	v := m.addbirthday_month
	if v == nil {
		return
	}
	return *v, true
}

// ResetBirthdayMonth resets all changes to the "birthday_month" field.
func (m *UserMutation) ResetBirthdayMonth() {
	m.birthday_month = nil
	m.addbirthday_month = nil
}

// SetBirthdayDay sets the "birthday_day" field.
func (m *UserMutation) SetBirthdayDay(i int) {
	m.birthday_day = &i
	m.addbirthday_day = nil
}

// BirthdayDay returns the value of the "birthday_day" field in the mutation.
func (m *UserMutation) BirthdayDay() (r int, exists bool) {
	v := m.birthday_day
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthdayDay returns the old "birthday_day" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthdayDay(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthdayDay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthdayDay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthdayDay: %w", err)
	}
	return oldValue.BirthdayDay, nil
}

// AddBirthdayDay adds i to the "birthday_day" field.
func (m *UserMutation) AddBirthdayDay(i int) {
	if m.addbirthday_day != nil {
		*m.addbirthday_day += i
	} else {
		m.addbirthday_day = &i
	}
}

// AddedBirthdayDay returns the value that was added to the "birthday_day" field in this mutation.
func (m *UserMutation) AddedBirthdayDay() (r int, exists bool) {
	v := m.addbirthday_day
	if v == nil {
		return
	}
	return *v, true
}

// ResetBirthdayDay resets all changes to the "birthday_day" field.
func (m *UserMutation) ResetBirthdayDay() {
	m.birthday_day = nil
	m.addbirthday_day = nil
}

// SetJob sets the "job" field.
func (m *UserMutation) SetJob(s string) {
	m.job = &s
}

// Job returns the value of the "job" field in the mutation.
func (m *UserMutation) Job() (r string, exists bool) {
	v := m.job
	if v == nil {
		return
	}
	return *v, true
}

// OldJob returns the old "job" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldJob(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJob is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJob requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJob: %w", err)
	}
	return oldValue.Job, nil
}

// ClearJob clears the value of the "job" field.
func (m *UserMutation) ClearJob() {
	m.job = nil
	m.clearedFields[user.FieldJob] = struct{}{}
}

// JobCleared returns if the "job" field was cleared in this mutation.
func (m *UserMutation) JobCleared() bool {
	_, ok := m.clearedFields[user.FieldJob]
	return ok
}

// ResetJob resets all changes to the "job" field.
func (m *UserMutation) ResetJob() {
	m.job = nil
	delete(m.clearedFields, user.FieldJob)
}

// SetBelongTo sets the "belong_to" field.
func (m *UserMutation) SetBelongTo(s string) {
	m.belong_to = &s
}

// BelongTo returns the value of the "belong_to" field in the mutation.
func (m *UserMutation) BelongTo() (r string, exists bool) {
	v := m.belong_to
	if v == nil {
		return
	}
	return *v, true
}

// OldBelongTo returns the old "belong_to" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBelongTo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBelongTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBelongTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBelongTo: %w", err)
	}
	return oldValue.BelongTo, nil
}

// ClearBelongTo clears the value of the "belong_to" field.
func (m *UserMutation) ClearBelongTo() {
	m.belong_to = nil
	m.clearedFields[user.FieldBelongTo] = struct{}{}
}

// BelongToCleared returns if the "belong_to" field was cleared in this mutation.
func (m *UserMutation) BelongToCleared() bool {
	_, ok := m.clearedFields[user.FieldBelongTo]
	return ok
}

// ResetBelongTo resets all changes to the "belong_to" field.
func (m *UserMutation) ResetBelongTo() {
	m.belong_to = nil
	delete(m.clearedFields, user.FieldBelongTo)
}

// SetPr sets the "pr" field.
func (m *UserMutation) SetPr(s string) {
	m.pr = &s
}

// Pr returns the value of the "pr" field in the mutation.
func (m *UserMutation) Pr() (r string, exists bool) {
	v := m.pr
	if v == nil {
		return
	}
	return *v, true
}

// OldPr returns the old "pr" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPr(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPr: %w", err)
	}
	return oldValue.Pr, nil
}

// ClearPr clears the value of the "pr" field.
func (m *UserMutation) ClearPr() {
	m.pr = nil
	m.clearedFields[user.FieldPr] = struct{}{}
}

// PrCleared returns if the "pr" field was cleared in this mutation.
func (m *UserMutation) PrCleared() bool {
	_, ok := m.clearedFields[user.FieldPr]
	return ok
}

// ResetPr resets all changes to the "pr" field.
func (m *UserMutation) ResetPr() {
	m.pr = nil
	delete(m.clearedFields, user.FieldPr)
}

// AddActivityIDs adds the "activities" edge to the UserActivity entity by ids.
func (m *UserMutation) AddActivityIDs(ids ...int) {
	if m.activities == nil {
		m.activities = make(map[int]struct{})
	}
	for i := range ids {
		m.activities[ids[i]] = struct{}{}
	}
}

// ClearActivities clears the "activities" edge to the UserActivity entity.
func (m *UserMutation) ClearActivities() {
	m.clearedactivities = true
}

// ActivitiesCleared reports if the "activities" edge to the UserActivity entity was cleared.
func (m *UserMutation) ActivitiesCleared() bool {
	return m.clearedactivities
}

// RemoveActivityIDs removes the "activities" edge to the UserActivity entity by IDs.
func (m *UserMutation) RemoveActivityIDs(ids ...int) {
	if m.removedactivities == nil {
		m.removedactivities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.activities, ids[i])
		m.removedactivities[ids[i]] = struct{}{}
	}
}

// RemovedActivities returns the removed IDs of the "activities" edge to the UserActivity entity.
func (m *UserMutation) RemovedActivitiesIDs() (ids []int) {
	for id := range m.removedactivities {
		ids = append(ids, id)
	}
	return
}

// ActivitiesIDs returns the "activities" edge IDs in the mutation.
func (m *UserMutation) ActivitiesIDs() (ids []int) {
	for id := range m.activities {
		ids = append(ids, id)
	}
	return
}

// ResetActivities resets all changes to the "activities" edge.
func (m *UserMutation) ResetActivities() {
	m.activities = nil
	m.clearedactivities = false
	m.removedactivities = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.key != nil {
		fields = append(fields, user.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.nickname != nil {
		fields = append(fields, user.FieldNickname)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.birthday_year != nil {
		fields = append(fields, user.FieldBirthdayYear)
	}
	if m.birthday_month != nil {
		fields = append(fields, user.FieldBirthdayMonth)
	}
	if m.birthday_day != nil {
		fields = append(fields, user.FieldBirthdayDay)
	}
	if m.job != nil {
		fields = append(fields, user.FieldJob)
	}
	if m.belong_to != nil {
		fields = append(fields, user.FieldBelongTo)
	}
	if m.pr != nil {
		fields = append(fields, user.FieldPr)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldKey:
		return m.Key()
	case user.FieldName:
		return m.Name()
	case user.FieldNickname:
		return m.Nickname()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldBirthdayYear:
		return m.BirthdayYear()
	case user.FieldBirthdayMonth:
		return m.BirthdayMonth()
	case user.FieldBirthdayDay:
		return m.BirthdayDay()
	case user.FieldJob:
		return m.Job()
	case user.FieldBelongTo:
		return m.BelongTo()
	case user.FieldPr:
		return m.Pr()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldKey:
		return m.OldKey(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldNickname:
		return m.OldNickname(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldBirthdayYear:
		return m.OldBirthdayYear(ctx)
	case user.FieldBirthdayMonth:
		return m.OldBirthdayMonth(ctx)
	case user.FieldBirthdayDay:
		return m.OldBirthdayDay(ctx)
	case user.FieldJob:
		return m.OldJob(ctx)
	case user.FieldBelongTo:
		return m.OldBelongTo(ctx)
	case user.FieldPr:
		return m.OldPr(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldBirthdayYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthdayYear(v)
		return nil
	case user.FieldBirthdayMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthdayMonth(v)
		return nil
	case user.FieldBirthdayDay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthdayDay(v)
		return nil
	case user.FieldJob:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJob(v)
		return nil
	case user.FieldBelongTo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBelongTo(v)
		return nil
	case user.FieldPr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPr(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addbirthday_year != nil {
		fields = append(fields, user.FieldBirthdayYear)
	}
	if m.addbirthday_month != nil {
		fields = append(fields, user.FieldBirthdayMonth)
	}
	if m.addbirthday_day != nil {
		fields = append(fields, user.FieldBirthdayDay)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldBirthdayYear:
		return m.AddedBirthdayYear()
	case user.FieldBirthdayMonth:
		return m.AddedBirthdayMonth()
	case user.FieldBirthdayDay:
		return m.AddedBirthdayDay()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldBirthdayYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBirthdayYear(v)
		return nil
	case user.FieldBirthdayMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBirthdayMonth(v)
		return nil
	case user.FieldBirthdayDay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBirthdayDay(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldNickname) {
		fields = append(fields, user.FieldNickname)
	}
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.FieldCleared(user.FieldJob) {
		fields = append(fields, user.FieldJob)
	}
	if m.FieldCleared(user.FieldBelongTo) {
		fields = append(fields, user.FieldBelongTo)
	}
	if m.FieldCleared(user.FieldPr) {
		fields = append(fields, user.FieldPr)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldNickname:
		m.ClearNickname()
		return nil
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case user.FieldJob:
		m.ClearJob()
		return nil
	case user.FieldBelongTo:
		m.ClearBelongTo()
		return nil
	case user.FieldPr:
		m.ClearPr()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldKey:
		m.ResetKey()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldNickname:
		m.ResetNickname()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldBirthdayYear:
		m.ResetBirthdayYear()
		return nil
	case user.FieldBirthdayMonth:
		m.ResetBirthdayMonth()
		return nil
	case user.FieldBirthdayDay:
		m.ResetBirthdayDay()
		return nil
	case user.FieldJob:
		m.ResetJob()
		return nil
	case user.FieldBelongTo:
		m.ResetBelongTo()
		return nil
	case user.FieldPr:
		m.ResetPr()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.activities != nil {
		edges = append(edges, user.EdgeActivities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.activities))
		for id := range m.activities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedactivities != nil {
		edges = append(edges, user.EdgeActivities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.removedactivities))
		for id := range m.removedactivities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedactivities {
		edges = append(edges, user.EdgeActivities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeActivities:
		return m.clearedactivities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeActivities:
		m.ResetActivities()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserActivityMutation represents an operation that mutates the UserActivity nodes in the graph.
type UserActivityMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	name          *string
	url           *string
	icon          *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserActivity, error)
	predicates    []predicate.UserActivity
}

var _ ent.Mutation = (*UserActivityMutation)(nil)

// useractivityOption allows management of the mutation configuration using functional options.
type useractivityOption func(*UserActivityMutation)

// newUserActivityMutation creates new mutation for the UserActivity entity.
func newUserActivityMutation(c config, op Op, opts ...useractivityOption) *UserActivityMutation {
	m := &UserActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeUserActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserActivityID sets the ID field of the mutation.
func withUserActivityID(id int) useractivityOption {
	return func(m *UserActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *UserActivity
		)
		m.oldValue = func(ctx context.Context) (*UserActivity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserActivity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserActivity sets the old UserActivity of the mutation.
func withUserActivity(node *UserActivity) useractivityOption {
	return func(m *UserActivityMutation) {
		m.oldValue = func(context.Context) (*UserActivity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserActivityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserActivityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserActivity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserActivityMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserActivityMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserActivity entity.
// If the UserActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserActivityMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserActivityMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserActivityMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserActivityMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserActivity entity.
// If the UserActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserActivityMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserActivityMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *UserActivityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserActivityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UserActivity entity.
// If the UserActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserActivityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserActivityMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *UserActivityMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *UserActivityMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the UserActivity entity.
// If the UserActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserActivityMutation) OldURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *UserActivityMutation) ClearURL() {
	m.url = nil
	m.clearedFields[useractivity.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *UserActivityMutation) URLCleared() bool {
	_, ok := m.clearedFields[useractivity.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *UserActivityMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, useractivity.FieldURL)
}

// SetIcon sets the "icon" field.
func (m *UserActivityMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *UserActivityMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the UserActivity entity.
// If the UserActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserActivityMutation) OldIcon(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *UserActivityMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[useractivity.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *UserActivityMutation) IconCleared() bool {
	_, ok := m.clearedFields[useractivity.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *UserActivityMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, useractivity.FieldIcon)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserActivityMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserActivityMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserActivityMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserActivityMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserActivityMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserActivityMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserActivityMutation builder.
func (m *UserActivityMutation) Where(ps ...predicate.UserActivity) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserActivityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserActivity).
func (m *UserActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserActivityMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, useractivity.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, useractivity.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, useractivity.FieldName)
	}
	if m.url != nil {
		fields = append(fields, useractivity.FieldURL)
	}
	if m.icon != nil {
		fields = append(fields, useractivity.FieldIcon)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useractivity.FieldCreateTime:
		return m.CreateTime()
	case useractivity.FieldUpdateTime:
		return m.UpdateTime()
	case useractivity.FieldName:
		return m.Name()
	case useractivity.FieldURL:
		return m.URL()
	case useractivity.FieldIcon:
		return m.Icon()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useractivity.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case useractivity.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case useractivity.FieldName:
		return m.OldName(ctx)
	case useractivity.FieldURL:
		return m.OldURL(ctx)
	case useractivity.FieldIcon:
		return m.OldIcon(ctx)
	}
	return nil, fmt.Errorf("unknown UserActivity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useractivity.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case useractivity.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case useractivity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case useractivity.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case useractivity.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	}
	return fmt.Errorf("unknown UserActivity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserActivityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserActivityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserActivity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserActivityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(useractivity.FieldURL) {
		fields = append(fields, useractivity.FieldURL)
	}
	if m.FieldCleared(useractivity.FieldIcon) {
		fields = append(fields, useractivity.FieldIcon)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserActivityMutation) ClearField(name string) error {
	switch name {
	case useractivity.FieldURL:
		m.ClearURL()
		return nil
	case useractivity.FieldIcon:
		m.ClearIcon()
		return nil
	}
	return fmt.Errorf("unknown UserActivity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserActivityMutation) ResetField(name string) error {
	switch name {
	case useractivity.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case useractivity.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case useractivity.FieldName:
		m.ResetName()
		return nil
	case useractivity.FieldURL:
		m.ResetURL()
		return nil
	case useractivity.FieldIcon:
		m.ResetIcon()
		return nil
	}
	return fmt.Errorf("unknown UserActivity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, useractivity.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case useractivity.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserActivityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, useractivity.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case useractivity.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserActivityMutation) ClearEdge(name string) error {
	switch name {
	case useractivity.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserActivity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserActivityMutation) ResetEdge(name string) error {
	switch name {
	case useractivity.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserActivity edge %s", name)
}

// UserCareerMutation represents an operation that mutates the UserCareer nodes in the graph.
type UserCareerMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserCareer, error)
	predicates    []predicate.UserCareer
}

var _ ent.Mutation = (*UserCareerMutation)(nil)

// usercareerOption allows management of the mutation configuration using functional options.
type usercareerOption func(*UserCareerMutation)

// newUserCareerMutation creates new mutation for the UserCareer entity.
func newUserCareerMutation(c config, op Op, opts ...usercareerOption) *UserCareerMutation {
	m := &UserCareerMutation{
		config:        c,
		op:            op,
		typ:           TypeUserCareer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserCareerID sets the ID field of the mutation.
func withUserCareerID(id int) usercareerOption {
	return func(m *UserCareerMutation) {
		var (
			err   error
			once  sync.Once
			value *UserCareer
		)
		m.oldValue = func(ctx context.Context) (*UserCareer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserCareer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserCareer sets the old UserCareer of the mutation.
func withUserCareer(node *UserCareer) usercareerOption {
	return func(m *UserCareerMutation) {
		m.oldValue = func(context.Context) (*UserCareer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserCareerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserCareerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserCareerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserCareerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserCareer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserCareerMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserCareerMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserCareer entity.
// If the UserCareer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCareerMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserCareerMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserCareerMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserCareerMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserCareer entity.
// If the UserCareer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCareerMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserCareerMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the UserCareerMutation builder.
func (m *UserCareerMutation) Where(ps ...predicate.UserCareer) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserCareerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserCareer).
func (m *UserCareerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserCareerMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.create_time != nil {
		fields = append(fields, usercareer.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, usercareer.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserCareerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usercareer.FieldCreateTime:
		return m.CreateTime()
	case usercareer.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserCareerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usercareer.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case usercareer.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown UserCareer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCareerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usercareer.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case usercareer.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown UserCareer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserCareerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserCareerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCareerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserCareer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserCareerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserCareerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserCareerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserCareer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserCareerMutation) ResetField(name string) error {
	switch name {
	case usercareer.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case usercareer.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown UserCareer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserCareerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserCareerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserCareerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserCareerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserCareerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserCareerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserCareerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserCareer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserCareerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserCareer edge %s", name)
}

// UserCareerGroupMutation represents an operation that mutates the UserCareerGroup nodes in the graph.
type UserCareerGroupMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserCareerGroup, error)
	predicates    []predicate.UserCareerGroup
}

var _ ent.Mutation = (*UserCareerGroupMutation)(nil)

// usercareergroupOption allows management of the mutation configuration using functional options.
type usercareergroupOption func(*UserCareerGroupMutation)

// newUserCareerGroupMutation creates new mutation for the UserCareerGroup entity.
func newUserCareerGroupMutation(c config, op Op, opts ...usercareergroupOption) *UserCareerGroupMutation {
	m := &UserCareerGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeUserCareerGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserCareerGroupID sets the ID field of the mutation.
func withUserCareerGroupID(id int) usercareergroupOption {
	return func(m *UserCareerGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *UserCareerGroup
		)
		m.oldValue = func(ctx context.Context) (*UserCareerGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserCareerGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserCareerGroup sets the old UserCareerGroup of the mutation.
func withUserCareerGroup(node *UserCareerGroup) usercareergroupOption {
	return func(m *UserCareerGroupMutation) {
		m.oldValue = func(context.Context) (*UserCareerGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserCareerGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserCareerGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserCareerGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserCareerGroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserCareerGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserCareerGroupMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserCareerGroupMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserCareerGroup entity.
// If the UserCareerGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCareerGroupMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserCareerGroupMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserCareerGroupMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserCareerGroupMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserCareerGroup entity.
// If the UserCareerGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCareerGroupMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserCareerGroupMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the UserCareerGroupMutation builder.
func (m *UserCareerGroupMutation) Where(ps ...predicate.UserCareerGroup) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserCareerGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserCareerGroup).
func (m *UserCareerGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserCareerGroupMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.create_time != nil {
		fields = append(fields, usercareergroup.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, usercareergroup.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserCareerGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usercareergroup.FieldCreateTime:
		return m.CreateTime()
	case usercareergroup.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserCareerGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usercareergroup.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case usercareergroup.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown UserCareerGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCareerGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usercareergroup.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case usercareergroup.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown UserCareerGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserCareerGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserCareerGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCareerGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserCareerGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserCareerGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserCareerGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserCareerGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserCareerGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserCareerGroupMutation) ResetField(name string) error {
	switch name {
	case usercareergroup.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case usercareergroup.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown UserCareerGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserCareerGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserCareerGroupMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserCareerGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserCareerGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserCareerGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserCareerGroupMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserCareerGroupMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserCareerGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserCareerGroupMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserCareerGroup edge %s", name)
}

// UserNoteMutation represents an operation that mutates the UserNote nodes in the graph.
type UserNoteMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserNote, error)
	predicates    []predicate.UserNote
}

var _ ent.Mutation = (*UserNoteMutation)(nil)

// usernoteOption allows management of the mutation configuration using functional options.
type usernoteOption func(*UserNoteMutation)

// newUserNoteMutation creates new mutation for the UserNote entity.
func newUserNoteMutation(c config, op Op, opts ...usernoteOption) *UserNoteMutation {
	m := &UserNoteMutation{
		config:        c,
		op:            op,
		typ:           TypeUserNote,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserNoteID sets the ID field of the mutation.
func withUserNoteID(id int) usernoteOption {
	return func(m *UserNoteMutation) {
		var (
			err   error
			once  sync.Once
			value *UserNote
		)
		m.oldValue = func(ctx context.Context) (*UserNote, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserNote.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserNote sets the old UserNote of the mutation.
func withUserNote(node *UserNote) usernoteOption {
	return func(m *UserNoteMutation) {
		m.oldValue = func(context.Context) (*UserNote, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserNoteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserNoteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserNoteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserNoteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserNote.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserNoteMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserNoteMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserNote entity.
// If the UserNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNoteMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserNoteMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserNoteMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserNoteMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserNote entity.
// If the UserNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNoteMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserNoteMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the UserNoteMutation builder.
func (m *UserNoteMutation) Where(ps ...predicate.UserNote) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserNoteMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserNote).
func (m *UserNoteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserNoteMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.create_time != nil {
		fields = append(fields, usernote.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, usernote.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserNoteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usernote.FieldCreateTime:
		return m.CreateTime()
	case usernote.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserNoteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usernote.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case usernote.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown UserNote field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserNoteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usernote.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case usernote.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown UserNote field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserNoteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserNoteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserNoteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserNote numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserNoteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserNoteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserNoteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserNote nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserNoteMutation) ResetField(name string) error {
	switch name {
	case usernote.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case usernote.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown UserNote field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserNoteMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserNoteMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserNoteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserNoteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserNoteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserNoteMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserNoteMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserNote unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserNoteMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserNote edge %s", name)
}

// UserNoteItemMutation represents an operation that mutates the UserNoteItem nodes in the graph.
type UserNoteItemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserNoteItem, error)
	predicates    []predicate.UserNoteItem
}

var _ ent.Mutation = (*UserNoteItemMutation)(nil)

// usernoteitemOption allows management of the mutation configuration using functional options.
type usernoteitemOption func(*UserNoteItemMutation)

// newUserNoteItemMutation creates new mutation for the UserNoteItem entity.
func newUserNoteItemMutation(c config, op Op, opts ...usernoteitemOption) *UserNoteItemMutation {
	m := &UserNoteItemMutation{
		config:        c,
		op:            op,
		typ:           TypeUserNoteItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserNoteItemID sets the ID field of the mutation.
func withUserNoteItemID(id int) usernoteitemOption {
	return func(m *UserNoteItemMutation) {
		var (
			err   error
			once  sync.Once
			value *UserNoteItem
		)
		m.oldValue = func(ctx context.Context) (*UserNoteItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserNoteItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserNoteItem sets the old UserNoteItem of the mutation.
func withUserNoteItem(node *UserNoteItem) usernoteitemOption {
	return func(m *UserNoteItemMutation) {
		m.oldValue = func(context.Context) (*UserNoteItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserNoteItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserNoteItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserNoteItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserNoteItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserNoteItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserNoteItemMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserNoteItemMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserNoteItem entity.
// If the UserNoteItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNoteItemMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserNoteItemMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserNoteItemMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserNoteItemMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserNoteItem entity.
// If the UserNoteItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNoteItemMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserNoteItemMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the UserNoteItemMutation builder.
func (m *UserNoteItemMutation) Where(ps ...predicate.UserNoteItem) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserNoteItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserNoteItem).
func (m *UserNoteItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserNoteItemMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.create_time != nil {
		fields = append(fields, usernoteitem.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, usernoteitem.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserNoteItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usernoteitem.FieldCreateTime:
		return m.CreateTime()
	case usernoteitem.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserNoteItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usernoteitem.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case usernoteitem.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown UserNoteItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserNoteItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usernoteitem.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case usernoteitem.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown UserNoteItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserNoteItemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserNoteItemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserNoteItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserNoteItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserNoteItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserNoteItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserNoteItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserNoteItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserNoteItemMutation) ResetField(name string) error {
	switch name {
	case usernoteitem.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case usernoteitem.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown UserNoteItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserNoteItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserNoteItemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserNoteItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserNoteItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserNoteItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserNoteItemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserNoteItemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserNoteItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserNoteItemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserNoteItem edge %s", name)
}

// UserQualificationMutation represents an operation that mutates the UserQualification nodes in the graph.
type UserQualificationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserQualification, error)
	predicates    []predicate.UserQualification
}

var _ ent.Mutation = (*UserQualificationMutation)(nil)

// userqualificationOption allows management of the mutation configuration using functional options.
type userqualificationOption func(*UserQualificationMutation)

// newUserQualificationMutation creates new mutation for the UserQualification entity.
func newUserQualificationMutation(c config, op Op, opts ...userqualificationOption) *UserQualificationMutation {
	m := &UserQualificationMutation{
		config:        c,
		op:            op,
		typ:           TypeUserQualification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserQualificationID sets the ID field of the mutation.
func withUserQualificationID(id int) userqualificationOption {
	return func(m *UserQualificationMutation) {
		var (
			err   error
			once  sync.Once
			value *UserQualification
		)
		m.oldValue = func(ctx context.Context) (*UserQualification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserQualification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserQualification sets the old UserQualification of the mutation.
func withUserQualification(node *UserQualification) userqualificationOption {
	return func(m *UserQualificationMutation) {
		m.oldValue = func(context.Context) (*UserQualification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserQualificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserQualificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserQualificationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserQualificationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserQualification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserQualificationMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserQualificationMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserQualification entity.
// If the UserQualification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserQualificationMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserQualificationMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserQualificationMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserQualificationMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserQualification entity.
// If the UserQualification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserQualificationMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserQualificationMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the UserQualificationMutation builder.
func (m *UserQualificationMutation) Where(ps ...predicate.UserQualification) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserQualificationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserQualification).
func (m *UserQualificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserQualificationMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.create_time != nil {
		fields = append(fields, userqualification.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, userqualification.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserQualificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userqualification.FieldCreateTime:
		return m.CreateTime()
	case userqualification.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserQualificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userqualification.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case userqualification.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown UserQualification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserQualificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userqualification.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case userqualification.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown UserQualification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserQualificationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserQualificationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserQualificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserQualification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserQualificationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserQualificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserQualificationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserQualification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserQualificationMutation) ResetField(name string) error {
	switch name {
	case userqualification.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case userqualification.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown UserQualification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserQualificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserQualificationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserQualificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserQualificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserQualificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserQualificationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserQualificationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserQualification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserQualificationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserQualification edge %s", name)
}
